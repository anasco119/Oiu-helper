import os
import sqlite3
import time # <--- ÿ£ÿ∂ŸÅ Ÿáÿ∞ÿß ÿßŸÑÿ≥ÿ∑ÿ±
from datetime import datetime, timedelta
from flask import Flask
import telebot
from telebot.types import ChatPermissions
import threading
import logging
from dotenv import load_dotenv
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton
import docx
import fitz                     # PyMuPDF
import google.generativeai as genai
import requests
import cohere
from groq import Groq
import json
import re
from pptx import Presentation



# ŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿßŸÑÿ®Ÿäÿ¶ÿ©
load_dotenv()
BOT_TOKEN = os.getenv("BOT_TOKEN")
GROUP_ID = int(os.getenv("GROUP_ID"))
ADMIN_ID = int(os.getenv("ADMIN_ID"))
GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')
OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")
COHERE_API_KEY = os.getenv("COHERE_API_KEY")
GROQ_API_KEY = os.getenv("GROQ_API_KEY")
allowed_channels = set()
env_channels = os.getenv("ALLOWED_CHANNELS", "")
if env_channels.strip():
    allowed_channels = set(map(int, env_channels.split(",")))

OCR_API_KEY = os.getenv("OCR_SPACE_API_KEY", "helloworld")  # ŸÖŸÅÿ™ÿßÿ≠ ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä ŸÑŸÑÿßÿÆÿ™ÿ®ÿßÿ±
bot = telebot.TeleBot(BOT_TOKEN)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-


# --- ÿ•ÿπÿØÿßÿØ ÿßŸÑŸÖŸÅÿßÿ™Ÿäÿ≠ ŸàÿßŸÑÿπŸÖŸÑ

session = {}  # <--- ÿ£ÿ∂ŸÅ Ÿáÿ∞ÿß ÿßŸÑÿ≥ÿ∑ÿ±

# 1. ÿ•ÿπÿØÿßÿØ Google Gemini
gemini_model = None
if GEMINI_API_KEY:
    try:
        genai.configure(api_key=GEMINI_API_KEY)
        gemini_model = genai.GenerativeModel('gemini-1.5-flash')
        logging.info("‚úÖ 1. Gemini configured successfully")
    except Exception as e:
        logging.warning(f"‚ö†Ô∏è Could not configure Gemini: {e}")

# 2. ÿ•ÿπÿØÿßÿØ Groq
groq_client = None
if GROQ_API_KEY:
    try:
        groq_client = Groq(api_key=GROQ_API_KEY)
        logging.info("‚úÖ 2. Groq configured successfully")
    except Exception as e:
        logging.warning(f"‚ö†Ô∏è Could not configure Groq: {e}")

# 3. ÿ•ÿπÿØÿßÿØ OpenRouter (ÿ≥Ÿäÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖŸá ŸÑŸÜŸÖŸàÿ∞ÿ¨ŸäŸÜ ŸÖÿÆÿ™ŸÑŸÅŸäŸÜ)
if OPENROUTER_API_KEY:
    logging.info("‚úÖ 3. OpenRouter is ready")

# 4. ÿ•ÿπÿØÿßÿØ Cohere
cohere_client = None
if COHERE_API_KEY:
    try:
        cohere_client = cohere.Client(COHERE_API_KEY)
        logging.info("‚úÖ 4. Cohere configured successfully")
    except Exception as e:
        logging.warning(f"‚ö†Ô∏è Could not configure Cohere: {e}")


# --- ÿßŸÑÿØÿßŸÑÿ© ÿßŸÑŸÖŸàÿ≠ÿØÿ© ŸÑÿ™ŸàŸÑŸäÿØ ÿßŸÑÿ±ÿØŸàÿØ ---

def generate_gemini_response(prompt: str) -> str:
    """
    Tries to generate a response by attempting a chain of services silently.
    It logs errors for the developer but does not send progress messages to the user.
    """
    timeout_seconds = 45

    # 1Ô∏è‚É£ OpenRouter - Nous Hermes 2 (ÿ£ŸÅÿ∂ŸÑ ÿØÿπŸÖ ŸÑŸÑÿπÿ±ÿ®Ÿäÿ©)
    if OPENROUTER_API_KEY:
        try:
            logging.info("Attempting request with: 1. OpenRouter (Nous Hermes 2)...")
            headers = {
            "Authorization": f"Bearer {OPENROUTER_API_KEY}",
            "HTTP-Referer": "https://t.me/Oiuhelper_bot",  # ‚Üê ÿ∫ŸäŸëÿ± Ÿáÿ∞ÿß ÿ•ŸÑŸâ ÿ±ÿßÿ®ÿ∑ ÿßŸÑÿ®Ÿàÿ™
            "X-Title": "AI Quiz Bot"
            }
            model_identifier = "nousresearch/nous-hermes-2-mistral:free"
            response = requests.post(
            url="https://openrouter.ai/api/v1/chat/completions",
            headers=headers,
                json={
                "model": model_identifier,
                "messages": [{"role": "user", "content": prompt}]
            },
            timeout=timeout_seconds
            )
            response.raise_for_status()
            result_text = response.json()['choices'][0]['message']['content']
            logging.info("‚úÖ Success with OpenRouter (Nous Hermes 2).")
            return result_text
        except Exception as e:
            logging.warning(f"‚ùå OpenRouter (Nous Hermes 2) failed: {e}")

    # 2Ô∏è‚É£ Groq (LLaMA 3)
    if groq_client:
        try:
            logging.info("Attempting request with: 2. Groq (LLaMA 3)...")
            chat_completion = groq_client.chat.completions.create(
                messages=[{"role": "user", "content": prompt}],
                model="llama3-8b-8192",
                temperature=0.7,
                timeout=timeout_seconds
            )
            if chat_completion.choices[0].message.content:
                logging.info("‚úÖ Success with Groq.")
                return chat_completion.choices[0].message.content
            else:
                logging.warning("‚ùå Groq returned no text. Trying fallback...")
        except Exception as e:
            logging.warning(f"‚ùå Groq failed: {e}")

    # 3Ô∏è‚É£ OpenRouter - Gemma
    if OPENROUTER_API_KEY:
        try:
            logging.info("Attempting request with: 3. OpenRouter (Gemma)...")
            headers = {
                "Authorization": f"Bearer {OPENROUTER_API_KEY}",
                "HTTP-Referer": "https://t.me/Oiuhelper_bot",  # Replace with your bot's link
                "X-Title": "AI Quiz Bot"
            }
            model_identifier = "google/gemma-7b-it:free"
            response = requests.post(
                url="https://openrouter.ai/api/v1/chat/completions",
                headers=headers,
                json={"model": model_identifier, "messages": [{"role": "user", "content": prompt}]},
                timeout=timeout_seconds
            )
            response.raise_for_status()
            result_text = response.json()['choices'][0]['message']['content']
            logging.info("‚úÖ Success with OpenRouter (Gemma).")
            return result_text
        except Exception as e:
            logging.warning(f"‚ùå OpenRouter (Gemma) failed: {e}")

    # 4Ô∏è‚É£ Google Gemini
    if gemini_model:
        try:
            logging.info("Attempting request with: 4. Google Gemini...")
            request_options = {"timeout": timeout_seconds}
            response = gemini_model.generate_content(prompt, request_options=request_options)
            if response.text:
                logging.info("‚úÖ Success with Gemini.")
                return response.text
            else:
                logging.warning("‚ùå Gemini returned no text. Trying fallback...")
        except Exception as e:
            logging.warning(f"‚ùå Gemini failed: {e}")

    # 5Ô∏è‚É£ Cohere
    if cohere_client:
        try:
            logging.info("Attempting request with: 5. Cohere...")
            response = cohere_client.chat(model='command-r', message=prompt)
            logging.info("‚úÖ Success with Cohere.")
            return response.text
        except Exception as e:
            logging.warning(f"‚ùå Cohere failed: {e}")

    # üö´ All models failed
    logging.error("‚ùå All API providers failed. Returning empty string.")
    return ""


def generate_smart_response(prompt: str) -> str:
    """
    Tries to generate a response by attempting a chain of services silently.
    It logs errors for the developer but does not send progress messages to the user.
    """
    timeout_seconds = 45


    #  1Ô∏è‚É£ Cohere
    if cohere_client:
        try:
            logging.info("Attempting request with: 5. Cohere...")
            response = cohere_client.chat(model='command-r', message=prompt, temperature=0.8)
            logging.info("‚úÖ Success with Cohere.")
            return response.text
        except Exception as e:
            logging.warning(f"‚ùå Cohere failed: {e}")



    # 2Ô∏è‚É£ Google Gemini
    if gemini_model:
        try:
            logging.info("Attempting request with: 4. Google Gemini...")
            request_options = {"timeout": timeout_seconds}
            response = gemini_model.generate_content(prompt, request_options=request_options, temperature=0.8)
            if response.text:
                logging.info("‚úÖ Success with Gemini.")
                return response.text
            else:
                logging.warning("‚ùå Gemini returned no text. Trying fallback...")
        except Exception as e:
            logging.warning(f"‚ùå Gemini failed: {e}")


    #  3Ô∏è‚É£  Groq (LLaMA 3)
    if groq_client:
        try:
            logging.info("Attempting request with: 2. Groq (LLaMA 3)...")
            chat_completion = groq_client.chat.completions.create(
                messages=[{"role": "user", "content": prompt}],
                model="llama3-8b-8192",
                temperature=0.8,
                timeout=timeout_seconds
            )
            if chat_completion.choices[0].message.content:
                logging.info("‚úÖ Success with Groq.")
                return chat_completion.choices[0].message.content
            else:
                logging.warning("‚ùå Groq returned no text. Trying fallback...")
        except Exception as e:
            logging.warning(f"‚ùå Groq failed: {e}")

    # 4Ô∏è‚É£# 5Ô∏è‚É£ OpenRouter - Gemma
    if OPENROUTER_API_KEY:
        try:
            logging.info("Attempting request with: 3. OpenRouter (Gemma)...")
            headers = {
                "Authorization": f"Bearer {OPENROUTER_API_KEY}",
                "HTTP-Referer": "https://t.me/Oiuhelper_bot",  # Replace with your bot's link
                "X-Title": "AI Quiz Bot"
            }
            model_identifier = "google/gemma-7b-it:free"
            response = requests.post(
                url="https://openrouter.ai/api/v1/chat/completions",
                headers=headers,
                json={"model": model_identifier, "messages": [{"role": "user", "content": prompt}]},
                timeout=timeout_seconds
            )
            response.raise_for_status()
            result_text = response.json()['choices'][0]['message']['content']
            logging.info("‚úÖ Success with OpenRouter (Gemma).")
            return result_text
        except Exception as e:
            logging.warning(f"‚ùå OpenRouter (Gemma) failed: {e}")

    # üö´ All models failed
    logging.error("‚ùå All API providers failed. Returning empty string.")
    return ""

# -------------------------------------------------------------------
#                 OCR + language detection & translation 
# -------------------------------------------------------------------

def translate_text(text, source='en', target='ar'):
    url = 'https://libretranslate.de/translate'
    payload = {
        'q': text,
        'source': source,
        'target': target,
        'format': 'text'
    }
    try:
        response = requests.post(url, data=payload)
        return response.json()['translatedText']
    except Exception as e:
        print("ÿ™ÿ±ÿ¨ŸÖÿ© ŸÅÿ¥ŸÑÿ™:", e)
        return text  # fallback


from flask import Flask, render_template, session, request, redirect, url_for

def save_user_major(user_id, major):
    with sqlite3.connect("quiz_users.db", check_same_thread=False) as conn:
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO users (user_id, major)
            VALUES (?, ?)
            ON CONFLICT(user_id) DO UPDATE SET major=excluded.major
        """, (user_id, major))
        conn.commit()


from langdetect import detect

def detect_language(text: str) -> str:
    try:
        lang = detect(text)
        return lang
    except:
        return "unknown"

def detect_language_from_filename(filename: str) -> str:
    """
    Ÿäÿ≠ÿßŸàŸÑ ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÑÿ∫ÿ© ÿßŸÑŸÖŸÜÿßÿ≥ÿ®ÿ© ŸÖŸÜ ÿßÿ≥ŸÖ ÿßŸÑŸÖŸÑŸÅ.
    ÿ•ÿ∞ÿß ÿßÿ≠ÿ™ŸàŸâ ÿπŸÑŸâ ÿ≠ÿ±ŸàŸÅ ÿπÿ±ÿ®Ÿäÿ© ‚Üí Ÿäÿ±ÿ¨Ÿëÿ≠ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©.
    ÿÆŸÑÿßŸÅ ÿ∞ŸÑŸÉ ‚Üí ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ©.
    """
    for char in filename:
        if '\u0600' <= char <= '\u06FF':  # ŸÜÿ∑ÿßŸÇ ÿßŸÑÿ≠ÿ±ŸàŸÅ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©
            return "ara"
    return "eng"

def extract_text_with_ocr_space(file_path: str, api_key="helloworld", language="eng") -> tuple:
    """
    Uses OCR.Space API to extract text from an image or scanned PDF.
    Returns: (text, debug_info)
    """
    url = 'https://api.ocr.space/parse/image'
    with open(file_path, 'rb') as f:
        response = requests.post(
            url,
            files={"file": f},
            data={
                "apikey": api_key,
                "language": language,
                "isOverlayRequired": False,
                "OCREngine": 2
            },
        )

    try:
        result = response.json()
        if result.get("IsErroredOnProcessing"):
            error_msg = result.get("ErrorMessage", "Unknown OCR error")
            return "", f"[OCR ERROR] {error_msg}"
        
        parsed = result.get("ParsedResults")
        if not parsed:
            return "", "[OCR ERROR] No ParsedResults returned."

        text = parsed[0].get("ParsedText", "").strip()
        return text, f"[OCR DEBUG] Length: {len(text)} | Excerpt: {text[:100]}"
    
    except Exception as e:
        return "", f"[OCR EXCEPTION] {e}"

# -------------------------------------------------------------------
#                  Logging & Database Setup
# -------------------------------------------------------------------
logging.basicConfig(level=logging.INFO,
                    format="%(asctime)s [%(levelname)s] %(message)s")

conn   = sqlite3.connect("quiz_users.db", check_same_thread=False)
cursor = conn.cursor()

# ÿ¨ÿØŸàŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ
cursor.execute("""
CREATE TABLE IF NOT EXISTS users (
    user_id     INTEGER PRIMARY KEY,
    major       TEXT,
    native_lang TEXT DEFAULT 'ar',
    quiz_count  INTEGER DEFAULT 0,
    last_reset  TEXT
)
""")

# ÿ¨ÿØŸàŸÑ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑŸÖŸÇÿ™ÿ±ÿ≠ÿ© ŸÖŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ŸÑŸÑÿπÿ®ÿ© ÿßŸÑÿßÿ≥ÿ™ŸÜÿ™ÿßÿ¨
cursor.execute("""
CREATE TABLE IF NOT EXISTS inference_questions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    question TEXT NOT NULL,
    options TEXT NOT NULL,         -- ÿ≥Ÿäÿ™ŸÖ ÿ™ÿÆÿ≤ŸäŸÜŸáÿß ŸÉÿ≥ŸÑÿ≥ŸÑÿ© JSON
    correct_index INTEGER NOT NULL,
    submitted_by INTEGER,
    approved INTEGER DEFAULT 0
)
""")
cursor.execute("""
CREATE TABLE IF NOT EXISTS game_attempts (
    user_id INTEGER,
    game_type TEXT,
    date TEXT,
    PRIMARY KEY (user_id, game_type)
)
""")
cursor.execute("""
CREATE TABLE IF NOT EXISTS recent_questions (
    user_id INTEGER,
    game_type TEXT,
    question TEXT,
    added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
""")
conn.commit()


# track temporary state for custom-major input
user_states = {}

# -------------------------------------------------------------------
#                     Text Extraction & OCR
# -------------------------------------------------------------------

def extract_text_from_pdf(path: str) -> str:
    try:
        doc = fitz.open(path)
        text = "\n".join([page.get_text() for page in doc])
        return text.strip()
    except Exception as e:
        logging.error(f"Error extracting PDF text: {e}")
        return ""
    # fallback to PyMuPDF text extraction
    doc = fitz.open(path)
    return "\n".join([page.get_text() for page in doc])
# ÿ£ÿ∂ŸÅ Ÿáÿ∞Ÿá ÿßŸÑÿØÿßŸÑÿ© ŸÅŸä ŸÇÿ≥ŸÖ Text Extraction & OCR
def extract_text_from_docx(path: str) -> str:
    try:
        doc = docx.Document(path)
        full_text = []
        for para in doc.paragraphs:
            full_text.append(para.text)
        return '\n'.join(full_text)
    except Exception as e:
        logging.error(f"Error extracting DOCX text: {e}")
        return ""

# ŸàŸäÿ¨ÿ® ÿ£Ÿäÿ∂ÿßŸã ÿ™ÿπÿ±ŸäŸÅ ÿØÿßŸÑÿ© ŸÑŸÖŸÑŸÅÿßÿ™ txt
def extract_text_from_txt(path: str) -> str:
    try:
        with open(path, 'r', encoding='utf-8') as f:
            return f.read()
    except Exception as e:
        logging.error(f"Error extracting TXT text: {e}")
        return ""
        
def is_text_empty(text: str) -> bool:
    return not text or len(text.strip()) < 30  # ŸäŸÖŸÉŸÜ ÿ™ÿπÿØŸäŸÑ ÿßŸÑÿ≠ÿØ ÿ≠ÿ≥ÿ® ÿ™ÿ¨ÿ±ÿ®ÿ™ŸÉ


def extract_text_from_pptx(path: str) -> str:
    try:
        prs = Presentation(path)
        all_text = []
        for slide in prs.slides:
            for shape in slide.shapes:
                if hasattr(shape, "text"):
                    all_text.append(shape.text)
        return "\n".join(all_text).strip()
    except Exception as e:
        logging.error(f"Error extracting PPTX text: {e}")
        return ""

def split_text(content, chunk_size=3500):
    return [content[i:i+chunk_size] for i in range(0, len(content), chunk_size)]

def summarize_long_text(content: str) -> str:
    """
    Summarize the content in its original language (Arabic or English) using educational style.
    """
    lang = detect_language(content[:1000])  # ŸÜŸÉÿ™ŸÅŸä ÿ®ÿ£ŸàŸÑ 1000 ÿ≠ÿ±ŸÅ ŸÑŸÑÿ™ÿ≠ŸÑŸäŸÑ
    print(f"[DEBUG] Detected language: {lang}")

    if lang.startswith("ar"):
        summary_prompt = (
            "ÿ£ŸÜÿ™ ŸÖÿ≥ÿßÿπÿØ ÿ™ÿπŸÑŸäŸÖŸä ŸÖÿ≠ÿ™ÿ±ŸÅ. ŸÇŸÖ ÿ®ÿ™ŸÑÿÆŸäÿµ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑÿ™ÿßŸÑŸä ÿ®ÿ£ÿ≥ŸÑŸàÿ® ÿ™ÿπŸÑŸäŸÖŸä ŸÖŸÜÿ∏ŸÖ ŸàŸàÿßÿ∂ÿ≠ ÿ®ÿßŸÑŸÑÿ∫ÿ© ÿßŸÑÿπÿ±ÿ®Ÿäÿ© ŸÅŸÇÿ∑ÿå"
            " ŸÖÿπ ÿßŸÑÿ≠ŸÅÿßÿ∏ ÿπŸÑŸâ ÿßŸÑŸÜŸÇÿßÿ∑ ÿßŸÑŸÖŸÅŸäÿØÿ© ŸàÿßŸÑÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿ™Ÿä ŸäŸÖŸÉŸÜ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖŸáÿß ŸÑÿßÿ≠ŸÇŸãÿß ŸÑÿµŸÜÿπ ÿ£ÿ≥ÿ¶ŸÑÿ© ÿ£Ÿà ÿ®ÿ∑ÿßŸÇÿßÿ™ ÿ™ÿπŸÑŸäŸÖŸäÿ©."
            "\n\nÿßŸÑŸÖÿ≠ÿ™ŸàŸâ:\n{chunk}"
        )
        merge_prompt = (
            "ŸÅŸäŸÖÿß ŸäŸÑŸä ŸÖÿ¨ŸÖŸàÿπÿ© ŸÖŸÜ ÿßŸÑŸÖŸÑÿÆÿµÿßÿ™ ÿßŸÑÿ¨ÿ≤ÿ¶Ÿäÿ© ŸÑŸÖÿ≠ÿ™ŸàŸâ ÿ™ÿπŸÑŸäŸÖŸä. ŸÇŸÖ ÿ®ÿØŸÖÿ¨Ÿáÿß ŸÅŸä ŸÖŸÑÿÆÿµ ŸÜŸáÿßÿ¶Ÿä ÿ¥ÿßŸÖŸÑ ŸàŸÖÿ™ÿ±ÿßÿ®ÿ∑ ŸàŸàÿßÿ∂ÿ≠"
            " ÿ®ÿßŸÑŸÑÿ∫ÿ© ÿßŸÑÿπÿ±ÿ®Ÿäÿ©ÿå ŸÖÿπ ÿßŸÑÿ≠ŸÅÿßÿ∏ ÿπŸÑŸâ ÿßŸÑÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑŸÖŸÅŸäÿØÿ© ÿßŸÑÿ™Ÿä ÿ™ÿ≥ÿßÿπÿØ ÿπŸÑŸâ ŸÅŸáŸÖ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿ£Ÿà ÿ•ÿπÿØÿßÿØ ÿßÿÆÿ™ÿ®ÿßÿ± ŸÖŸÜŸá.\n\n{merged}"
        )
    else:
        summary_prompt = (
            "You are a professional educational assistant. Summarize the following content into a clear and concise educational explanation in **English only**.\n\n"
            "- Preserve factual details and key definitions.\n"
            "- Avoid vague sentences or repetition.\n"
            "- Keep the original language (do not translate).\n\nContent:\n{chunk}"
        )
        merge_prompt = (
            "You are an educational summarizer. Merge the following partial summaries into one final, well-structured summary in **English**, preserving all useful learning content.\n\n{merged}"
        )

    chunks = split_text(content)
    partial_summaries = []

    for i, chunk in enumerate(chunks):
        prompt = summary_prompt.format(chunk=chunk)
        summary = generate_smart_response(prompt.strip())
        partial_summaries.append(summary)

    merged_summary = "\n".join(partial_summaries)
    final_prompt = merge_prompt.format(merged=merged_summary)
    return generate_smart_response(final_prompt.strip())
    

def parse_ai_json(raw_text: str) -> dict | None:
    """
    1) Ÿäÿ≠ŸàŸëŸÑ Ÿáÿßÿ±ÿ®ÿßÿ™ Unicode ÿ•ŸÑŸâ ŸÜÿµ ÿπÿ±ÿ®Ÿä.
    2) ŸäŸÇÿ∑Ÿëÿπ ÿ£ŸàŸÑ ŸÉÿ™ŸÑÿ© JSON ŸÖŸàÿ¨ŸàÿØÿ© ÿØÿßÿÆŸÑ ÿßŸÑŸÜÿµ ÿ•ŸÜ ŸÑŸÖ ŸäŸÉŸÜ ÿßŸÑÿ±ÿØ ŸÜŸÇŸäŸëŸãÿß.
    3) Ÿäÿ≠ÿßŸàŸÑ json.loads ÿπÿØÿ© ŸÖÿ±ÿßÿ™.
    4) Ÿäÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ®ŸÜŸäÿ© ÿßŸÑŸÜÿßÿ™ÿ¨ ŸÇÿ®ŸÑ ÿßŸÑÿ•ÿ±ÿ¨ÿßÿπ.
    """
    # 1. ŸÅŸÉŸëŸè Ÿáÿßÿ±ÿ®ÿßÿ™ Unicode (\u0627 ‚Üí ÿß)
    def _unescape(match):
        code = match.group(1)
        return chr(int(code, 16))
    text = re.sub(r'\\u([0-9A-Fa-f]{4})', _unescape, raw_text)

    # 2. ÿßÿ¨ÿ™ÿ≤ÿ° ÿ£ŸàŸÑ ŸÉÿ™ŸÑÿ© JSON (ŸÖŸÜ { ÿ•ŸÑŸâ })
    m = re.search(r'\{[\s\S]*\}', text)
    json_text = m.group(0) if m else text

    # 3. ÿ≠ÿßŸàŸÑ ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ
    for attempt in (json_text, text):
        try:
            data = json.loads(attempt)
            break
        except json.JSONDecodeError:
            data = None
    if not data:
        return None

    # 4. ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ®ŸÜŸäÿ© ÿßŸÑŸÄ dict
    if not all(k in data for k in ("question", "options", "correct_index")):
        return None

    # 5. ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ options ŸÇÿßÿ¶ŸÖÿ© ŸàÿµÿßŸÑÿ≠ÿ©
    if not isinstance(data["options"], list) or len(data["options"]) < 2:
        return None

    # 6. ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ correct_index
    ci = data["correct_index"]
    if not isinstance(ci, int) or ci < 0 or ci >= len(data["options"]):
        return None

    return data

def generate_game(prompt, user_id=0, translate_all=False, translate_question=False):
    if user_id == ADMIN_ID or can_generate(user_id):  # <-- ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸáŸÜÿß
        raw_response = generate_smart_response(prompt)
    else:
        raw_response = generate_gemini_response(prompt)
        
    game_data = parse_ai_json(raw_response)

    if not game_data:
        raise ValueError("ŸÅÿ¥ŸÑ ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÑÿπÿ®ÿ©")

    if translate_all:
        # ÿ™ÿ±ÿ¨ŸÖÿ© ÿßŸÑÿ≥ÿ§ÿßŸÑ
        if 'question' in game_data:
            game_data['question'] = translate_text(game_data['question'], source='en', target='ar')

        # ÿ™ÿ±ÿ¨ŸÖÿ© ŸÉŸÑ ÿßŸÑÿÆŸäÿßÿ±ÿßÿ™
        if 'options' in game_data and isinstance(game_data['options'], list):
            game_data['options'] = [
                translate_text(option, source='en', target='ar') for option in game_data['options']
            ]

    elif translate_question:
        # ÿ™ÿ±ÿ¨ŸÖÿ© ÿßŸÑÿ≥ÿ§ÿßŸÑ ŸÅŸÇÿ∑
        if 'question' in game_data:
            game_data['question'] = translate_text(game_data['question'], source='en', target='ar')

    return game_data

import genanki
import time
import uuid

def save_cards_to_apkg(cards: list, filename='anki_flashcards.apkg', deck_name="My Flashcards"):
    model = genanki.Model(
        1607392319,
        'Simple Model',
        fields=[
            {'name': 'Front'},
            {'name': 'Back'},
        ],
        templates=[
            {
                'name': 'Card 1',
                'qfmt': '{{Front}}',
                'afmt': '{{FrontSide}}<hr id="answer">{{Back}}',
            },
        ]
    )

    deck = genanki.Deck(
        deck_id=int(str(uuid.uuid4().int)[:9]),  # ŸÑÿ™ŸàŸÑŸäÿØ ÿ±ŸÇŸÖ deck ÿπÿ¥Ÿàÿßÿ¶Ÿä ŸàŸÅÿ±ŸäÿØ
        name=deck_name
    )

    seen = set()
    for card in cards:
        front = card.get('front', '').strip()
        back = card.get('back', '').strip()
        if front and back and front not in seen:
            note = genanki.Note(model=model, fields=[front, back])
            deck.add_note(note)
            seen.add(front)

    genanki.Package(deck).write_to_file(filename)
    return filename

    
# -------------------------------------------------------------------
#                     Quota Management
# -------------------------------------------------------------------
def add_recent_question(user_id, game_type, question):
    with sqlite3.connect("quiz_users.db") as conn:
        cursor = conn.cursor()
        
        # ÿ•ÿØÿÆÿßŸÑ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ¨ÿØŸäÿØ
        cursor.execute("""
        INSERT INTO recent_questions (user_id, game_type, question) 
        VALUES (?, ?, ?)
        """, (user_id, game_type, question))
        
        # ÿ≠ÿ∞ŸÅ ÿßŸÑÿ£ŸÇÿØŸÖ ÿ•ÿ∞ÿß ÿ™ÿ¨ÿßŸàÿ≤ 10 ÿ£ÿ≥ÿ¶ŸÑÿ©
        cursor.execute("""
        DELETE FROM recent_questions
        WHERE user_id = ? AND game_type = ?
        AND question NOT IN (
            SELECT question FROM recent_questions
            WHERE user_id = ? AND game_type = ?
            ORDER BY added_at DESC
            LIMIT 10
        )
        """, (user_id, game_type, user_id, game_type))

        conn.commit()

def get_recent_questions(user_id, game_type):
    with sqlite3.connect("quiz_users.db") as conn:
        cursor = conn.cursor()
        cursor.execute("""
        SELECT question FROM recent_questions
        WHERE user_id = ? AND game_type = ?
        ORDER BY added_at DESC
        LIMIT 10
        """, (user_id, game_type))
        rows = cursor.fetchall()
        return [row[0] for row in rows]


def reset_if_needed(user_id: int):
    this_month = datetime.now().strftime("%Y-%m")
    cursor.execute("SELECT last_reset FROM users WHERE user_id = ?", (user_id,))
    row = cursor.fetchone()
    if not row or row[0] != this_month:
        cursor.execute("""
            INSERT OR REPLACE INTO users(user_id, major, quiz_count, last_reset)
            VALUES (?, COALESCE((SELECT major FROM users WHERE user_id=?), ''), 0, ?)
        """, (user_id, user_id, this_month))
        conn.commit()

def can_generate(user_id: int) -> bool:
    # ‚úÖ ÿßŸÑÿ≥ŸÖÿßÿ≠ ŸÑŸÑÿ£ÿØŸÖŸÜ ÿØÿßÿ¶ŸÖÿßŸã
    if user_id == ADMIN_ID:
        return True

    try:
        # ‚úÖ ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠ ÿ®Ÿáÿß (ÿ•ÿ∞ÿß ŸÖŸÜ env)
        allowed_channels = set(map(int, os.getenv("ALLOWED_CHANNELS", "").split(",")))

        for channel_id in allowed_channels:
            try:
                # ÿßŸÑÿ™ÿ≠ŸÇŸÇ ÿ•ŸÜ ŸÉÿßŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿπÿ∂ŸàÿßŸã ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ©
                member = bot.get_chat_member(chat_id=channel_id, user_id=user_id)
                if member.status in ['member', 'administrator', 'creator']:
                    return True
            except Exception as e:
                logging.warning(f"ŸÅÿ¥ŸÑ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿπÿ∂ŸàŸäÿ© ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ© {channel_id} ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ {user_id}: {e}")
    except Exception as e:
        logging.error(f"ÿÆÿ∑ÿ£ ŸÅŸä can_generate: {e}")

    return False
    # --- ŸÜŸáÿßŸäÿ© ÿßŸÑÿ™ÿπÿØŸäŸÑ ---

    reset_if_needed(user_id)
    cursor.execute("SELECT quiz_count FROM users WHERE user_id = ?", (user_id,))
    row = cursor.fetchone()
    # ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÖŸàÿ¨ŸàÿØ ŸÇÿ®ŸÑ ŸÖÿ≠ÿßŸàŸÑÿ© ÿßŸÑŸàÿµŸàŸÑ ÿ•ŸÑŸâ ÿßŸÑÿπÿØ
    if not row:
        return True # ŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ¨ÿØŸäÿØÿå ŸäŸÖŸÉŸÜŸá ÿßŸÑÿ™ŸàŸÑŸäÿØ
    count = row[0]
    return count < 6

def increment_count(user_id: int):
    # --- ÿ®ÿØÿßŸäÿ© ÿßŸÑÿ™ÿπÿØŸäŸÑ ---
    # ŸÑÿß ÿ™ŸÇŸÖ ÿ®ÿ≤ŸäÿßÿØÿ© ÿßŸÑÿπÿØÿßÿØ ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸáŸà ÿßŸÑÿ£ÿØŸÖŸÜ
    if user_id == ADMIN_ID:
        bot.send_message(ADMIN_ID, "‚ú® (Ÿàÿ∂ÿπ ÿßŸÑÿ£ÿØŸÖŸÜ: ŸÑŸÖ Ÿäÿ™ŸÖ ÿßÿ≠ÿ™ÿ≥ÿßÿ® Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ©)")
        return
    # --- ŸÜŸáÿßŸäÿ© ÿßŸÑÿ™ÿπÿØŸäŸÑ ---
    
    cursor.execute("UPDATE users SET quiz_count = quiz_count + 1 WHERE user_id = ?", (user_id,))
    conn.commit()

from datetime import date

def can_play_game_today(user_id: int, game_type: str) -> bool:
    if str(user_id) == str(ADMIN_ID):  # ŸÖŸÇÿßÿ±ŸÜÿ© ÿ¢ŸÖŸÜÿ© ŸÑÿ£ŸÜ ADMIN_ID ÿ£ÿ≠ŸäÿßŸÜŸãÿß ŸäŸÉŸàŸÜ str
        return True

    today = str(date.today())
    cursor.execute(
        "SELECT 1 FROM game_attempts WHERE user_id = ? AND game_type = ? AND date = ?",
        (user_id, game_type, today)
    )
    return cursor.fetchone() is None

def record_game_attempt(user_id: int, game_type: str):
    if str(user_id) == str(ADMIN_ID):
        return  # ŸÑÿß ÿ™ÿ≥ÿ¨ŸÑ ŸÑŸÑÿ£ÿØŸÖŸÜ

    today = str(date.today())
    cursor.execute(
        "INSERT OR REPLACE INTO game_attempts(user_id, game_type, date) VALUES (?, ?, ?)",
        (user_id, game_type, today)
    )
    conn.commit()
from collections import defaultdict

# ÿ™ÿÆÿ≤ŸäŸÜ ŸÖÿ§ŸÇÿ™ ŸÅŸä ÿßŸÑÿ∞ÿßŸÉÿ±ÿ©
game_states = defaultdict(dict)  # {user_id: {game_type: count}}

def get_question_count(user_id, game_type):
    return game_states.get(user_id, {}).get(game_type, 0)

def increment_question_count(user_id, game_type):
    game_states[user_id][game_type] = game_states.get(user_id, {}).get(game_type, 0) + 1
    
# -------------------------------------------------------------------
#                 Quiz Generation & Formatting
# -------------------------------------------------------------------

def extract_json_from_string(text: str) -> str:
    """
    Extracts a JSON string from a text that might contain markdown code blocks or other text.
    """
    # ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿ®ŸÑŸàŸÉ JSON ÿØÿßÿÆŸÑ ```json ... ```
    match = re.search(r'```json\s*([\s\S]*?)\s*```', text)
    if match:
        return match.group(1).strip()

    # ÿ•ÿ∞ÿß ŸÑŸÖ Ÿäÿ¨ÿØ ÿ®ŸÑŸàŸÉÿå ÿßÿ®ÿ≠ÿ´ ÿπŸÜ ÿ£ŸàŸÑ '{' ÿ£Ÿà '[' Ÿàÿ¢ÿÆÿ± '}' ÿ£Ÿà ']'
    start = -1
    end = -1
    
    # ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿ®ÿØÿßŸäÿ© ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿ£Ÿà ÿßŸÑŸÉÿßÿ¶ŸÜ
    first_brace = text.find('{')
    first_bracket = text.find('[')
    
    if first_brace == -1:
        start = first_bracket
    elif first_bracket == -1:
        start = first_brace
    else:
        start = min(first_brace, first_bracket)

    # ÿ•ÿ∞ÿß ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ®ÿØÿßŸäÿ©ÿå ÿ£ÿ±ÿ¨ÿπ ÿßŸÑŸÜÿµ ÿßŸÑÿ£ÿµŸÑŸä
    if start == -1:
        return text

    # ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ŸÜŸáÿßŸäÿ© ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿ£Ÿà ÿßŸÑŸÉÿßÿ¶ŸÜ
    last_brace = text.rfind('}')
    last_bracket = text.rfind(']')
    end = max(last_brace, last_bracket)

    # ÿ•ÿ∞ÿß ÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ®ÿØÿßŸäÿ© ŸàŸÜŸáÿßŸäÿ©ÿå ÿ£ÿ±ÿ¨ÿπ ŸÖÿß ÿ®ŸäŸÜŸáŸÖÿß
    if end > start:
        return text[start:end+1].strip()
        
    # ŸÉÿÆŸäÿßÿ± ÿ£ÿÆŸäÿ±ÿå ÿ£ÿ±ÿ¨ÿπ ÿßŸÑŸÜÿµ ŸÉŸÖÿß ŸáŸà
    return text
    
def generate_quizzes_from_text(content: str, major: str, user_id: int, num_quizzes: int = 10):  # <-- ÿ£ÿ∂ŸÅ user_id
    prompt = (
    f"You are a strict AI quiz generator. Your only task is to generate a JSON array of {num_quizzes} quiz questions "
    f"that are based **strictly and only** on the information explicitly stated in the following content.\n\n"
    "‚ùóÔ∏èImportant Rules:\n"
    "- DO NOT invent, infer, or assume any information not clearly mentioned in the text.\n"
    "- If a concept is not explained or mentioned clearly in the content, DO NOT create a question about it.\n"
    "- Stay fully inside the boundaries of the content.\n"
    "- Every question must test **recall** or **recognition** from the provided text only, not general knowledge.\n\n"
    "Each question must be an object with:\n"
    "- 'question': the question string\n"
    "- 'options': a list of exactly 4 answer options\n"
    "- 'correct_index': the index (0-3) of the correct answer in the options list\n"
    "- 'explanation': short sentence to explain **why this is the correct answer**, max 2 lines\n\n"
    "‚ö†Ô∏è Format Instructions:\n"
    "- ONLY return a raw JSON array. No markdown, no explanation, no formatting.\n"
    "- Do not include any introductory or closing text.\n"
    "- Ensure the JSON is valid and parsable.\n\n"
    f"Content:\n{content}"
    )

    # ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑÿØÿßŸÑÿ© ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿµŸÑÿßÿ≠Ÿäÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
    if user_id == ADMIN_ID or can_generate(user_id):  # <-- ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸáŸÜÿß
        raw_response = generate_smart_response(prompt)
    else:
        raw_response = generate_gemini_response(prompt)
    
    # --- ÿßŸÑÿ™ÿπÿØŸäŸÑ Ÿäÿ®ÿØÿ£ ŸáŸÜÿß ---
    # 1. ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© ŸÑÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿßŸÑŸÄ JSON
    clean_json_str = extract_json_from_string(raw_response)
    
    # 2. ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÖÿß ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© ŸÅÿßÿ±ÿ∫ÿ© ÿ®ÿπÿØ ÿßŸÑÿ™ŸÜÿ∏ŸäŸÅ
    if not clean_json_str:
        logging.error(f"‚ùå JSON extraction failed. Raw output was:\n{raw_response}")
        return [] # ÿ£ÿ±ÿ¨ÿπ ŸÇÿßÿ¶ŸÖÿ© ŸÅÿßÿ±ÿ∫ÿ© ÿ®ÿØŸÑÿßŸã ŸÖŸÜ ÿ±ÿ≥ÿßŸÑÿ© ÿÆÿ∑ÿ£

    try:
        # 3. ŸÖÿ≠ÿßŸàŸÑÿ© ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ≥ŸÑÿ≥ŸÑÿ© ÿßŸÑŸÜÿ∏ŸäŸÅÿ©
        quizzes_json = json.loads(clean_json_str)
        quizzes = []

        for item in quizzes_json:
            q = item.get("question", "").strip()
            opts = item.get("options", [])
            corr = item.get("correct_index", -1)
            expl = item.get("explanation", "").strip()

            if isinstance(q, str) and q and isinstance(opts, list) and len(opts) == 4 and isinstance(corr, int) and 0 <= corr < 4:
                quizzes.append((q, [str(opt).strip() for opt in opts], corr, expl))
            else:
                logging.warning(f"‚ùå Skipping invalid question structure: {item}")

        return quizzes

    except json.JSONDecodeError as e:
        logging.error(f"‚ùå JSON parsing failed: {e}\nCleaned string was:\n{clean_json_str}\nRaw output was:\n{raw_response}")
        return [] # ÿ£ÿ±ÿ¨ÿπ ŸÇÿßÿ¶ŸÖÿ© ŸÅÿßÿ±ÿ∫ÿ© ÿπŸÜÿØ ÿßŸÑŸÅÿ¥ŸÑ
    # --- ÿßŸÑÿ™ÿπÿØŸäŸÑ ŸäŸÜÿ™ŸáŸä ŸáŸÜÿß ---


def generate_anki_cards_from_text(content: str, major: str = "General", user_id: int = 0, num_cards: int = 15) -> tuple:
    for attempt in range(3):  # ÿ™ÿ¨ÿ±ÿ®ÿ© ÿ≠ÿ™Ÿâ 3 ŸÖÿ±ÿßÿ™
        prompt = f"""
You are an AI assistant specialized in creating study flashcards.

üéØ Task:
Extract the most important {num_cards} points from the following content, and convert each into an **Anki-style flashcard**.

üîπ Rules:
- Each flashcard must include:
  - "front": a short question or hint.
  - "back": the detailed answer or explanation.
  - "tag": (optional) topic label like Grammar, Biology, Logic, etc.
- The front must be phrased to encourage recall (e.g. "What is...", "Define...", "How does...").
- Don't use Markdown, just clean plain text.
- Keep the cards diverse and helpful.
- Output must be a valid JSON **object** with two keys: "title" and "cards".

üö´ Important:
- Do NOT generate multiple choice or true/false questions.
- Only generate flashcards suitable for Anki with a front and a back.
- The flashcards must be written in the same language as the input content. If the content is in Arabic, answer in Arabic. If English, answer in English.

üìò Content to process (field: {major}):
{content}

‚úÖ Example output format:
{{
  "title": "Basics of Organic Chemistry",
  "cards": [
    {{
      "front": "What is the function of mitochondria?",
      "back": "It is the powerhouse of the cell.",
      "tag": "Biology"
    }},
    {{
      "front": "ŸÖÿß ŸáŸä ÿßŸÑÿßÿ≥ÿ™ÿπÿßÿ±ÿ©ÿü",
      "back": "ÿßŸÑÿßÿ≥ÿ™ÿπÿßÿ±ÿ© ŸáŸä ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÉŸÑŸÖÿ© ŸÅŸä ÿ∫Ÿäÿ± ŸÖÿπŸÜÿßŸáÿß ÿßŸÑÿ≠ŸÇŸäŸÇŸä ŸÑÿπŸÑÿßŸÇÿ© ŸÖÿπ ŸÇÿ±ŸäŸÜÿ© ŸÖÿßŸÜÿπÿ©.",
      "tag": "Literature"
    }}
  ]
}}
"""
        if user_id == ADMIN_ID or can_generate(user_id):  # <-- ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸáŸÜÿß
            raw_output = generate_smart_response(prompt)
        else:
            raw_output = generate_gemini_response(prompt)
            
        clean_json = extract_json_from_string(raw_output)

        try:
            data = json.loads(clean_json)
            title = data.get("title", "ÿ®ÿ∑ÿßŸÇÿßÿ™ ÿ™ÿπŸÑŸäŸÖŸäÿ©")
            card_list = data.get("cards", [])

            cards = []
            for item in card_list:
                front = item.get("front") or item.get("question")
                back = item.get("back") or item.get("answer")

                if isinstance(front, str) and isinstance(back, str) and front.strip() and back.strip():
                    cards.append({"front": front.strip(), "back": back.strip()})
                else:
                    logging.warning(f"‚ùå Skipping invalid card: {item}")

            if len(cards) >= 5:
                return cards, title

        except json.JSONDecodeError as e:
            logging.error(f"‚ùå Failed to parse Anki cards: {e}\nClean JSON:\n{clean_json}\nRaw:\n{raw_output}")

    return [], "ÿ®ÿ∑ÿßŸÇÿßÿ™ ÿ™ÿπŸÑŸäŸÖŸäÿ©"   

    


# -------------------------------------------------------------------
#                 games
# -------------------------------------------------------------------
import random

topics = [
    "ÿ≠Ÿäÿßÿ© ÿßŸÑÿ∑ÿßŸÑÿ®", "ÿ™ÿÆÿ∑Ÿäÿ∑ ÿßŸÑÿ≥ŸÅÿ±", "ŸÖÿ¥ÿßÿ±Ÿäÿπ ÿ¨ŸÖÿßÿπŸäÿ©", "ŸÖŸÇÿßÿ®ŸÑÿßÿ™ ÿßŸÑÿπŸÖŸÑ",
    "ÿßŸÑÿ∂ÿ∫ÿ∑ ÿßŸÑÿ≤ŸÖŸÜŸä", "ŸÖŸàÿßŸÇŸÅ ÿπÿßÿ∑ŸÅŸäÿ©", "ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ™ŸÉŸÜŸàŸÑŸàÿ¨Ÿäÿß", "ŸÇÿ±ÿßÿ±ÿßÿ™ ŸÖÿßŸÑŸäÿ©",
    "ÿµÿ±ÿßÿπÿßÿ™ ÿßŸÑŸÅÿ±ŸäŸÇ", "ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑÿ£ŸáÿØÿßŸÅ"
]

def generate_vocabulary_game(user_id, major, native_lang="Arabic"):
    rand = random.randint(1000, 9999)
    recent = get_recent_questions(user_id, "vocab")
    recent_prompt = "\n".join(f"- {q}" for q in recent)
    
    prompt = f"""  
You are an AI vocabulary quiz creator.  
Generate one vocabulary question for a student majoring in {major}.
- Vocabulary should be relevant to real life or academic use and not an uncommon Vocabulary.
- Show the meaning of an English word in English 
- Provide 4 English words as options  
- Only ONE option should be correct.  
- Don't explain anything. Just give raw JSON.

Example:
{{
  "question": "Question",
  "options": ["Option", "Option", "Option", "Option"],
  "correct_index": 0
}}

Use this seed to diversify the question: {rand}
‚ùå Avoid repeating or paraphrasing these questions:
{recent_prompt}
"""
    q = generate_game(prompt)

    # ÿ≠ŸÅÿ∏ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ¨ÿØŸäÿØ
    add_recent_question(user_id, "speed", q["question"])
    return q

def generate_speed_challenge(user_id, major, native_lang="Arabic"):
    rand = random.randint(1000, 9999)
    recent = get_recent_questions(user_id, "speed")
    recent_prompt = "\n".join(f"- {q}" for q in recent)
    
    prompt = f"""
You are a quiz bot.

Generate a **fun, fast-answer quiz** for a student in {major}.

Requirements:
- The question must be in English.
- The 4 options must be in English.
- Use fun and fast general knowledge topics (e.g. logic, daily life trivia, or language puzzles). Avoid repeating the same categories.
- Keep it simple and not too academic.
- Return raw JSON only.
- No explanation.
- Use this seed to increase randomness: {rand}
‚ùå Avoid repeating or paraphrasing these questions:
{recent_prompt}

Example output:
{{
  "question": "Question?",
  "options": ["Option", "Option", "Option", "Option"],
  "correct_index": 0
}}
"""
    q = generate_game(prompt, translate_question=True)

    # ÿ≠ŸÅÿ∏ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ¨ÿØŸäÿØ
    add_recent_question(user_id, "speed", q["question"])
    return q
    

# ‚òÖ ŸÑÿπÿ®ÿ© ÿßŸÑÿßÿÆÿ∑ÿßÿ° ÿßŸÑÿ¥ÿßÿ¶ÿπÿ©
def generate_common_mistakes_game(user_id, major, native_lang="Arabic"):
    rand = random.randint(1000, 9999)
    recent = get_recent_questions(user_id, "mistakes")
    recent_prompt = "\n".join(f"- {q}" for q in recent)
    
    prompt = f"""
You are an educational game generator.

Your task:
- Generate a multiple-choice question highlighting a **common mistake** in the field of {major}.
- The question must be in English.
- The **options must be in English**.
- Provide **4 options** only, with one correct.
- Don't explain.
- Return only raw JSON.

‚ùå Avoid repeating or paraphrasing these questions:
{recent_prompt}
Use this random seed to diversify the question: {rand}

Example output:
{{
  "question": "Which sentence is grammatically incorrect?",
  "options": ["He go to school every day.", "She plays the piano.", "They are studying now.", "I have finished my homework."],
  "correct_index": 0
}}
"""
    q = generate_game(prompt, translate_question=True)

    # ÿ≠ŸÅÿ∏ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ¨ÿØŸäÿØ
    add_recent_question(user_id, "speed", q["question"])
    return q


def generate_inference_game(user_id, major, native_lang="Arabic"):
    rand = random.randint(1000, 9999)
    recent = get_recent_questions(user_id, "inference")
    recent_prompt = "\n".join(f"- {q}" for q in recent)
    
    random_topic = random.choice(topics)
    prompt = f"""
You are an AI-powered life skills test creator.

Generate a **new and unique** question that develops one of the following skills:  
- Critical thinking  
- Emotional intelligence  
- Time management  
- Self-awareness  
- Decision making  
- Problem solving  
- Logic  
- Pattern recognition  
- Mental map understanding  

üîπ **Requirements**:  
- Write the **question in Arabic**  
- Write **all options in Arabic**  
- Use a realistic scenario or student-life context related to: **{random_topic}**  
- Provide **exactly 4 options**, with **one correct answer**  
- **Never repeat** past examples or add explanations  
- Make the question **engaging and clever**  
- Incorporate variability using this random number: **{rand}**  
- the options should be as short as possible but understandable
‚ùå Avoid repeating or paraphrasing these questions:
{recent_prompt}
üî∏ Return **JSON-only output** (no additional text).  

Example (Johnson‚Äôs format):  
{{
  "question": "Question",  
  "options": ["Options", "Option", "Option", "Option"],  
  "correct_index": 2  
}}  
"""
    q = generate_game(prompt, translate_question=True)

    # ÿ≠ŸÅÿ∏ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ¨ÿØŸäÿØ
    add_recent_question(user_id, "speed", q["question"])
    return q
    
# ----------------------------------
# ------------- inference review -------------------------------------------------------------------


def review_inference_question_with_ai(question_text: str, options: list[str], correct_index: int) -> bool:
    prompt = f"""
You are an AI educational assistant.

A student submitted the following inference question. Review it and decide if it's valid:
- Is the question clear and meaningful?
- Are the 4 options distinct and related to the question?
- Is there **one and only one correct answer**?

Respond only with YES or NO.

Question: {question_text}
Options: {options}
Correct index: {correct_index}
"""
    response = generate_smart_response(prompt).strip().lower()
    return "yes" in response


def process_pending_inference_questions():
    cursor.execute("SELECT id, question, options, correct_index FROM inference_questions WHERE approved = 0")
    pending = cursor.fetchall()

    for row in pending:
        qid, qtext, options_json, correct_index = row
        try:
            options = json.loads(options_json)
        except:
            continue  # ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿ∞ÿßÿ™ ÿßŸÑÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑÿÆÿßÿ∑ÿ¶

        if review_inference_question_with_ai(qtext, options, correct_index):
            cursor.execute("UPDATE inference_questions SET approved = 1 WHERE id = ?", (qid,))
        else:
            cursor.execute("DELETE FROM inference_questions WHERE id = ?", (qid,))

    conn.commit()

import string

def generate_quiz_code(length=6):
    return ''.join(random.choices(string.ascii_lowercase + string.digits, k=length))

def store_user_quiz(user_id, quizzes, quiz_code):
    conn = sqlite3.connect("quiz_users.db")
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS user_quizzes (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER,
        quiz_data TEXT,
        quiz_code TEXT UNIQUE,
        created_at TEXT
    )''')

    c.execute('INSERT INTO user_quizzes (user_id, quiz_data, quiz_code, created_at) VALUES (?, ?, ?, ?)',
              (user_id, json.dumps(quizzes), quiz_code, datetime.utcnow().isoformat()))
    conn.commit()
    conn.close()

def send_quizzes_as_polls(chat_id: int, quizzes: list, message_id=None):
    """
    Sends a list of quizzes to a user as separate Telegram polls.
    """
    try:
        intro_text = f"‚úÖ ÿ™ŸÖ ÿ™ÿ¨ŸáŸäÿ≤ {len(quizzes)} ÿ≥ÿ§ÿßŸÑŸãÿß. ÿßÿ≥ÿ™ÿπÿØ ŸÑŸÑÿßÿÆÿ™ÿ®ÿßÿ±!"

        if message_id:
            bot.edit_message_text(chat_id=chat_id, message_id=message_id, text=intro_text)
        else:
            bot.send_message(chat_id, intro_text)
        time.sleep(2)

        for i, quiz_data in enumerate(quizzes):
            try:
                question, options, correct_index, explanation = quiz_data
                question_text = f"‚ùì ÿßŸÑÿ≥ÿ§ÿßŸÑ {i+1}:\n\n{question}"
                if len(question_text) > 300:
                    question_text = question_text[:297] + "..."

                bot.send_poll(
                    chat_id,
                    question=question_text,
                    options=options,
                    type="quiz",
                    correct_option_id=correct_index,
                    is_anonymous=False,
                    explanation=explanation
                )
                time.sleep(1.5)
            except Exception as e:
                print(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ≥ÿ§ÿßŸÑ {i+1}: {e}")
                continue


            
        bot.send_message(chat_id, "üéâ ÿßŸÜÿ™ŸáŸâ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±! ÿ®ÿßŸÑÿ™ŸàŸÅŸäŸÇ.")
            
    except Exception as main_error:
        print(f"ÿÆÿ∑ÿ£ ÿ±ÿ¶Ÿäÿ≥Ÿä ŸÅŸä ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±: {main_error}")
        bot.send_message(chat_id, "ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.")



# ÿ™ÿÆÿ≤ŸäŸÜ ÿ≠ÿßŸÑÿ© ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ± ŸÑŸÉŸÑ ŸÖÿ≥ÿ™ÿÆÿØŸÖ
user_quiz_state = {}

def start_quiz(chat_id, quiz_code, bot):
    """ÿ®ÿØÿ° ÿßÿÆÿ™ÿ®ÿßÿ± ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÉŸàÿØ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ± ÿßŸÑŸÖÿÆÿ≤ŸÜ"""
    # ÿ¨ŸÑÿ® ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ± ŸÖŸÜ ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÉŸàÿØ
    with sqlite3.connect("your_database.db") as conn:
        c = conn.cursor()
        c.execute("SELECT quiz_data FROM user_quizzes WHERE quiz_code = ?", (quiz_code,))
        result = c.fetchone()
        
        if not result:
            bot.send_message(chat_id, "‚ùå ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ± ÿßŸÑŸÖÿ∑ŸÑŸàÿ®.")
            return

        quizzes = json.loads(result[0])

    # ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÖŸÜ [question, options, correct_index, explanation] ÿ•ŸÑŸâ ÿßŸÑÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®
    quiz_data = []
    for quiz in quizzes:
        question, options, correct_index, explanation = quiz
        quiz_data.append([{
            "question": question,
            "options": options,
            "answer": options[correct_index],
            "explanation": explanation  # ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ™ŸÅÿ≥Ÿäÿ± ŸÑŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÑÿßÿ≠ŸÇŸãÿß ÿ•ÿ∞ÿß needed
        }])

    # ÿ≠ŸÅÿ∏ ÿ≠ÿßŸÑÿ© ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ± ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
    user_quiz_state[chat_id] = {
        'quizzes': quiz_data,
        'current_quiz': 0,
        'current_question': 0,
        'score': 0,
        'quiz_code': quiz_code  # ÿ≠ŸÅÿ∏ ŸÉŸàÿØ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ± ŸÑÿ£ÿ∫ÿ±ÿßÿ∂ ÿßŸÑÿ™ÿ™ÿ®ÿπ
    }

    # ÿ•ÿ±ÿ≥ÿßŸÑ ÿ£ŸàŸÑ ÿ≥ÿ§ÿßŸÑ
    send_next_question(chat_id, bot)

def send_next_question(chat_id, bot):
    """ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ™ÿßŸÑŸä ŸÅŸä ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±"""
    if chat_id not in user_quiz_state:
        return

    state = user_quiz_state[chat_id]
    quizzes = state['quizzes']
    quiz_idx = state['current_quiz']
    question_idx = state['current_question']

    if quiz_idx >= len(quizzes):
        # ÿßŸÜÿ™Ÿáÿßÿ° ÿ¨ŸÖŸäÿπ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™
        total_questions = sum(len(q) for q in quizzes)
        score_message = f"üèÅ ÿßŸÜÿ™ŸáŸâ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±!\n\nŸÜÿ™Ÿäÿ¨ÿ™ŸÉ: {state['score']}/{total_questions}"
        
        # ÿ•ÿ∂ÿßŸÅÿ© ÿ≤ÿ± ŸÑŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±
        keyboard = types.InlineKeyboardMarkup()
        share_button = types.InlineKeyboardButton(
            "ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±", 
            url=f"https://t.me/Oiuhelper_bot?start=qc_{state['quiz_code']}"
        )
        keyboard.add(share_button)
        
        bot.send_message(
            chat_id,
            score_message,
            reply_markup=keyboard
        )
        del user_quiz_state[chat_id]
        return

    current_quiz = quizzes[quiz_idx]
    
    if question_idx >= len(current_quiz):
        # ÿßŸÑÿßŸÜÿ™ŸÇÿßŸÑ ÿ•ŸÑŸâ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ± ÿßŸÑÿ™ÿßŸÑŸä
        state['current_quiz'] += 1
        state['current_question'] = 0
        send_next_question(chat_id, bot)
        return

    question_data = current_quiz[question_idx]
    
    # ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ≠ÿßŸÑŸä
    poll = bot.send_poll(
        chat_id=chat_id,
        question=question_data["question"],
        options=question_data["options"],
        is_anonymous=False,
        type='quiz',
        correct_option_id=question_data["options"].index(question_data["answer"]),
        explanation=question_data.get("explanation", "")  # ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ™ŸÅÿ≥Ÿäÿ± ÿ•ÿ∞ÿß ŸÖŸàÿ¨ŸàÿØ
    )

    # ÿ≠ŸÅÿ∏ ŸÖÿπÿ±ŸÅ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÑÿ™ÿ™ÿ®ÿπ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ©
    state['last_poll_message_id'] = poll.message_id

@bot.poll_answer_handler()
def handle_poll_answer(poll_answer):
    """ŸÖÿπÿßŸÑÿ¨ÿ© ÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿπŸÑŸâ ÿßŸÑÿ≥ÿ§ÿßŸÑ"""
    chat_id = poll_answer.user.id
    
    if chat_id not in user_quiz_state:
        return

    state = user_quiz_state[chat_id]
    
    # ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ≠ÿßŸÑŸä
    current_quiz = state['quizzes'][state['current_quiz']]
    current_question = current_quiz[state['current_question']]
    
    # ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ©
    correct_option = current_question["options"].index(current_question["answer"])
    if poll_answer.option_ids and poll_answer.option_ids[0] == correct_option:
        state['score'] += 1
        feedback = "‚úÖ ÿ•ÿ¨ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ©!"
    else:
        feedback = f"‚ùå ÿ•ÿ¨ÿßÿ®ÿ© ÿÆÿßÿ∑ÿ¶ÿ©! ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ© ŸáŸä: {current_question['answer']}"
    
    # ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ™ŸÅÿ≥Ÿäÿ± ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÖŸàÿ¨ŸàÿØŸãÿß
    if "explanation" in current_question and current_question["explanation"]:
        feedback += f"\n\nüí° ÿßŸÑÿ™ŸÅÿ≥Ÿäÿ±: {current_question['explanation']}"
    
    # ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ™ÿ∫ÿ∞Ÿäÿ© ÿßŸÑÿ±ÿßÿ¨ÿπÿ©
    bot.send_message(chat_id, feedback)
    
    # ÿßŸÑÿßŸÜÿ™ŸÇÿßŸÑ ÿ•ŸÑŸâ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ™ÿßŸÑŸä
    state['current_question'] += 1
    send_next_question(chat_id, bot)

# -------------------------------------------------------------------
#                  Telegram Bot Handlers
# -------------------------------------------------------------------
@bot.message_handler(commands=['start'])
def unified_start_handler(message):
    args = message.text.split()

    # ‚úÖ ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸáŸÜÿßŸÉ ÿ®ÿßÿ±ÿßŸÖŸäÿ™ÿ± (ŸÖÿ´ŸÑ quiz_ab12cd)
    if len(args) > 1:
        param = args[1]

        if param.startswith("quiz_"):
            quiz_code = param
            conn = sqlite3.connect("quiz_users.db")
            c = conn.cursor()
            c.execute("SELECT quiz_data FROM user_quizzes WHERE quiz_code = ?", (quiz_code,))
            result = c.fetchone()
            conn.close()

            if result:
                quizzes = json.loads(result[0])
                bot.send_message(message.chat.id, "üß† Ÿáÿ∞ÿß ÿßÿÆÿ™ÿ®ÿßÿ± ÿ™ŸÖÿ™ ŸÖÿ¥ÿßÿ±ŸÉÿ™Ÿá ŸÖÿπŸÉ. ÿßÿ≥ÿ™ÿπÿØ!")
                start_quiz(message.chat.id, quiz_code, bot)
            else:
                bot.send_message(message.chat.id, "‚ùå ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ Ÿáÿ∞ÿß ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±.")
            return  # ‚õî ŸÑÿß ÿ™ŸÉŸÖŸÑ ŸÑŸÑŸàÿßÿ¨Ÿáÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©

    # ‚úÖ ÿ•ÿ∞ÿß ŸÑŸÖ ŸäŸÉŸÜ ŸáŸÜÿßŸÉ ÿ£Ÿä ÿ®ÿßÿ±ÿßŸÖŸäÿ™ÿ± ÿ£Ÿà ŸÑŸäÿ≥ "quiz_" ‚Üí ÿπÿ±ÿ∂ ÿßŸÑŸàÿßÿ¨Ÿáÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©
    if message.chat.type != "private":
        return  # ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ŸÅŸä ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™

    keyboard = InlineKeyboardMarkup(row_width=2)
    buttons = [
        InlineKeyboardButton("üìù ÿ™ŸàŸÑŸäÿØ ÿßÿÆÿ™ÿ®ÿßÿ±", callback_data="go_generate"),
        InlineKeyboardButton("üìö ŸÖÿ±ÿßÿ¨ÿπÿ© ÿ≥ÿ±Ÿäÿπÿ©", callback_data="soon_review"),
        InlineKeyboardButton("üìÑ ŸÖŸÑÿÆÿµ PDF", callback_data="soon_summary"),
        InlineKeyboardButton("üß† ÿ®ÿ∑ÿßŸÇÿßÿ™ Anki", callback_data="anki"),
        InlineKeyboardButton("üéÆ ÿ£ŸÑÿπÿßÿ® ÿ™ÿπŸÑŸäŸÖŸäÿ©", callback_data="go_games"),
        InlineKeyboardButton("‚öôÔ∏è ÿ≠ÿ≥ÿßÿ®Ÿä", callback_data="go_account_settings"),
    ]
    keyboard.add(*buttons)
    keyboard.add(InlineKeyboardButton("‚ûï ÿ£ÿ∂ŸÅŸÜŸä ÿ•ŸÑŸâ ŸÖÿ¨ŸÖŸàÿπÿ©", url=f"https://t.me/{bot.get_me().username}?startgroup=true"))

    bot.send_message(
        message.chat.id,
        "üëã ÿ£ŸáŸÑÿß ÿ®ŸÉ ŸÅŸä *TestGenie* ‚ú®\n\n"
        "üéØ ÿ£ÿØŸàÿßÿ™ ÿ™ÿπŸÑŸäŸÖŸäÿ© ÿ∞ŸÉŸäÿ© ÿ®ŸäŸÜ ŸäÿØŸäŸÉ:\n"
        "- ÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™ ŸÖŸÜ ŸÖŸÑŸÅÿßÿ™ŸÉ\n"
        "- ÿ®ÿ∑ÿßŸÇÿßÿ™ ŸÖÿ±ÿßÿ¨ÿπÿ© (Anki)\n"
        "- ŸÖŸÑÿÆÿµÿßÿ™ PDF/Word _(ŸÇÿ±Ÿäÿ®ÿßŸã)_\n"
        "- ÿ£ŸÑÿπÿßÿ® ÿ™ÿπŸÑŸäŸÖŸäÿ© \n\n"
        "üìå ŸÉŸÑ ŸÖÿß ÿ™ÿ≠ÿ™ÿßÿ¨Ÿá ŸÑÿ™ÿ™ÿπŸÑŸëŸÖ ÿ®ÿ∞ŸÉÿßÿ°... ÿ®ŸäŸÜ ŸäÿØŸäŸÉ ÿßŸÑÿ¢ŸÜ..\n\n"
        "ÿßÿÆÿ™ÿ± ŸÖÿß ŸäŸÜÿßÿ≥ÿ®ŸÉ Ÿàÿßÿ®ÿØÿ£ ÿßŸÑÿ¢ŸÜ üëá",
        reply_markup=keyboard,
        parse_mode="Markdown"
    )


def send_main_menu(chat_id, message_id=None):
    keyboard = InlineKeyboardMarkup(row_width=2)
    buttons = [
        InlineKeyboardButton("üìù ÿ™ŸàŸÑŸäÿØ ÿßÿÆÿ™ÿ®ÿßÿ±", callback_data="go_generate"),
        InlineKeyboardButton("üìö ŸÖÿ±ÿßÿ¨ÿπÿ© ÿ≥ÿ±Ÿäÿπÿ©", callback_data="soon_review"),
        InlineKeyboardButton("üìÑ ŸÖŸÑÿÆÿµ PDF", callback_data="soon_summary"),
        InlineKeyboardButton("üß† ÿ®ÿ∑ÿßŸÇÿßÿ™ Anki", callback_data="anki"),
        InlineKeyboardButton("üéÆ ÿ£ŸÑÿπÿßÿ® ÿ™ÿπŸÑŸäŸÖŸäÿ©", callback_data="go_games"),
        InlineKeyboardButton("‚öôÔ∏è ÿ≠ÿ≥ÿßÿ®Ÿä", callback_data="go_account_settings"),
    ]
    keyboard.add(*buttons)
    keyboard.add(InlineKeyboardButton("‚ûï ÿ£ÿ∂ŸÅŸÜŸä ÿ•ŸÑŸâ ŸÖÿ¨ŸÖŸàÿπÿ©", url=f"https://t.me/{bot.get_me().username}?startgroup=true"))

    text = (
        "üëã ÿ£ŸáŸÑÿß ÿ®ŸÉ ŸÅŸä *TestGenie* ‚ú®\n\n"
        "üéØ ÿ£ÿØŸàÿßÿ™ ÿ™ÿπŸÑŸäŸÖŸäÿ© ÿ∞ŸÉŸäÿ© ÿ®ŸäŸÜ ŸäÿØŸäŸÉ:\n"
        "- ÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™ ŸÖŸÜ ŸÖŸÑŸÅÿßÿ™ŸÉ\n"
        "- ÿ®ÿ∑ÿßŸÇÿßÿ™ ŸÖÿ±ÿßÿ¨ÿπÿ© (Anki)\n"
        "- ŸÖŸÑÿÆÿµÿßÿ™ PDF/Word _(ŸÇÿ±Ÿäÿ®ÿßŸã)_\n"
        "- ÿ£ŸÑÿπÿßÿ® ÿ™ÿπŸÑŸäŸÖŸäÿ©\n\n"
        "üìå ŸÉŸÑ ŸÖÿß ÿ™ÿ≠ÿ™ÿßÿ¨Ÿá ŸÑÿ™ÿ™ÿπŸÑŸëŸÖ ÿ®ÿ∞ŸÉÿßÿ°... ÿ®ŸäŸÜ ŸäÿØŸäŸÉ ÿßŸÑÿ¢ŸÜ.\n\n"
        "ÿßÿÆÿ™ÿ± ŸÖÿß ŸäŸÜÿßÿ≥ÿ®ŸÉ Ÿàÿßÿ®ÿØÿ£ ÿßŸÑÿ¢ŸÜ üëá"
    )

    if message_id:
        bot.edit_message_text(text, chat_id=chat_id, message_id=message_id, reply_markup=keyboard, parse_mode="Markdown")
    else:
        bot.send_message(chat_id, text, reply_markup=keyboard, parse_mode="Markdown")


@bot.callback_query_handler(func=lambda c: True)
def handle_main_menu(c):
    if c.message.chat.type != "private":
        return
    # ÿ±ÿØŸàÿØ ÿÆÿßÿ∑ÿ¶ÿ© ÿπÿ¥Ÿàÿßÿ¶Ÿäÿ© ÿ™ÿ∏Ÿáÿ± ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
    wrong_responses = [
        "‚ùå ÿÆÿ∑ÿ£! ÿ¨ÿ±ÿ® ŸÖÿ¨ÿØÿØŸãÿß üòâ\n‚úÖ ÿßŸÑÿµÿ≠Ÿäÿ≠: {correct}",
        "üö´ ŸÑŸÑÿ£ÿ≥ŸÅÿå ŸÑŸäÿ≥ÿ™ ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©!\n‚úÖ ÿßŸÑÿ¨Ÿàÿßÿ®: {correct}",
        "üòÖ ŸÑŸäÿ≥ÿ™ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©ÿå ÿßŸÑÿ¨Ÿàÿßÿ® ŸáŸà: {correct}",
        "‚ùå ŸÑÿßÿå ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ!\n‚úîÔ∏è ÿßŸÑÿµÿ≠Ÿäÿ≠ ŸáŸà: {correct}"
    ]
    uid = c.from_user.id
    data = c.data
    chat_id = c.message.chat.id
    message_id = c.message.message_id

    # ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©
    if data == "go_generate":
        keyboard = InlineKeyboardMarkup()
        buttons = [
            ("ü©∫ ÿßŸÑÿ∑ÿ®", "major_ÿßŸÑÿ∑ÿ®"),
            ("üõ†Ô∏è ÿßŸÑŸáŸÜÿØÿ≥ÿ©", "major_ÿßŸÑŸáŸÜÿØÿ≥ÿ©"),
            ("üíä ÿßŸÑÿµŸäÿØŸÑÿ©", "major_ÿßŸÑÿµŸäÿØŸÑÿ©"),
            ("üó£Ô∏è ÿßŸÑŸÑÿ∫ÿßÿ™", "major_ÿßŸÑŸÑÿ∫ÿßÿ™"),
            ("‚ùì ÿ∫Ÿäÿ± ÿ∞ŸÑŸÉ...", "major_custom"),
        ]
        for text, data_btn in buttons:
            keyboard.add(InlineKeyboardButton(text, callback_data=data_btn))
        keyboard.add(InlineKeyboardButton("‚¨ÖÔ∏è ÿ±ÿ¨Ÿàÿπ", callback_data="go_back_home"))

        bot.edit_message_text(
            "üéØ Ÿáÿ∞ÿß ÿßŸÑÿ®Ÿàÿ™ Ÿäÿ≥ÿßÿπÿØŸÉ ÿπŸÑŸâ ÿ™ŸàŸÑŸäÿØ ÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™ ÿ∞ŸÉŸäÿ© ŸÖŸÜ ŸÖŸÑŸÅÿßÿ™ŸÉ ÿßŸÑÿØÿ±ÿßÿ≥Ÿäÿ© ÿ£Ÿà ÿßŸÑŸÜÿµŸàÿµ.\n"
            "üìå ŸÖÿ™ÿßÿ≠ ŸÑŸÉ 3 ÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™ ŸÖÿ¨ÿßŸÜŸäÿ© ÿ¥Ÿáÿ±ŸäŸãÿß.\n\n"
            "ÿßÿÆÿ™ÿ± ÿ™ÿÆÿµÿµŸÉ ŸÑŸÑÿ®ÿØÿ° üëá", 
            chat_id=chat_id,
            message_id=message_id,
            reply_markup=keyboard
        )
    elif data == "anki":
        bot.answer_callback_query(c.id)
        bot.send_message(uid, "üìÑ ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑÿ¢ŸÜ ŸÖŸÑŸÅ PDF ÿ£Ÿà Word ÿ£Ÿà ŸÜÿµŸãÿß ÿπÿßÿØŸäŸãÿß ŸÑÿ™ŸàŸÑŸäÿØ ÿ®ÿ∑ÿßŸÇÿßÿ™ ÿßŸÑŸÖÿ±ÿßÿ¨ÿπÿ© (Anki).")
        user_states[uid] = "awaiting_anki_file"  # ‚Üê ÿ™ÿ≠ÿØŸäÿØ ÿ≠ÿßŸÑÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ

    elif data == "go_account_settings":
        bot.answer_callback_query(c.id)
        settings_keyboard = InlineKeyboardMarkup()
        settings_keyboard.add(
            InlineKeyboardButton("üéì ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑÿ™ÿÆÿµÿµ", callback_data="change_specialty"),
        )
        settings_keyboard.add(
            InlineKeyboardButton("‚¨ÖÔ∏è ÿ±ÿ¨Ÿàÿπ", callback_data="go_back_home")
        )

        bot.edit_message_text(
            text="‚öôÔ∏è *ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ≠ÿ≥ÿßÿ®*\n\n"
                 "ŸäŸÖŸÉŸÜŸÉ ÿ™ÿÆÿµŸäÿµ ÿ™ÿ¨ÿ±ÿ®ÿ™ŸÉ ÿßŸÑÿ™ÿπŸÑŸäŸÖŸäÿ© ŸáŸÜÿß.\n"
                 "ÿßÿÆÿ™ÿ± ŸÖÿß ÿ™ÿ±ÿ∫ÿ® ÿ®ÿ™ÿπÿØŸäŸÑŸá üëá",
            chat_id=c.message.chat.id,
            message_id=c.message.message_id,
            reply_markup=settings_keyboard,
            parse_mode="Markdown"
        )
        
    elif data == "go_games":
        cursor.execute("SELECT major FROM users WHERE user_id = ?", (uid,))
        row = cursor.fetchone()

        if not row or not row[0]:
            user_states[uid] = "awaiting_major_for_games"
            bot.send_message(uid, "üß† ŸÇÿ®ŸÑ ÿ£ŸÜ ŸÜÿ®ÿØÿ£ ÿßŸÑŸÑÿπÿ®ÿå ÿ£ÿÆÿ®ÿ±ŸÜÿß ÿ®ÿ™ÿÆÿµÿµŸÉ:")
            return

        keyboard = InlineKeyboardMarkup(row_width=1)
        keyboard.add(
            InlineKeyboardButton("üîí ÿßŸÑÿπÿ® ŸÅŸä ÿßŸÑÿÆÿßÿµ", callback_data="game_private"),
            InlineKeyboardButton("üë• ÿßŸÑÿπÿ® ŸÅŸä ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©", switch_inline_query="game"),
            InlineKeyboardButton("üè† ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©", callback_data="go_back_home")
        )
        bot.edit_message_text(
            "üéÆ ÿßÿÆÿ™ÿ± ÿ∑ÿ±ŸäŸÇÿ© ÿßŸÑŸÑÿπÿ®:\n\n"
            "- üîí ŸÅŸä ÿßŸÑÿÆÿßÿµ (ÿ£ŸÑÿπÿßÿ® ÿ¥ÿÆÿµŸäÿ© ÿ≠ÿ≥ÿ® ÿ™ÿÆÿµÿµŸÉ)\n"
            "- üë• ŸÅŸä ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ© (ÿ¥ÿßÿ±ŸÉ ÿßŸÑÿ£ÿµÿØŸÇÿßÿ° ÿ®ÿßŸÑÿ™ÿ≠ÿØŸä!)",
            chat_id=chat_id,
            message_id=message_id,
            reply_markup=keyboard
        )
    
    elif data == "go_back_home":
        # ÿ•ÿπÿßÿØÿ© ÿπÿ±ÿ∂ Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑÿ®ÿØÿßŸäÿ©
        keyboard = InlineKeyboardMarkup(row_width=2)
        buttons = [
            InlineKeyboardButton("üìù ÿ™ŸàŸÑŸäÿØ ÿßÿÆÿ™ÿ®ÿßÿ±", callback_data="go_generate"),
            InlineKeyboardButton("üìö ŸÖÿ±ÿßÿ¨ÿπÿ© ÿ≥ÿ±Ÿäÿπÿ©", callback_data="soon_review"),
            InlineKeyboardButton("üìÑ ŸÖŸÑÿÆÿµ PDF", callback_data="soon_summary"),
            InlineKeyboardButton("üß† ÿ®ÿ∑ÿßŸÇÿßÿ™ Anki", callback_data="anki"),
            InlineKeyboardButton("üéÆ ÿ£ŸÑÿπÿßÿ® ÿ™ÿπŸÑŸäŸÖŸäÿ©", callback_data="go_games"),
            InlineKeyboardButton("‚öôÔ∏è ÿ≠ÿ≥ÿßÿ®Ÿä", callback_data="go_account_settings"),
        ]
        keyboard.add(*buttons)

        bot.edit_message_text(
            "üëã ÿ£ŸáŸÑÿßŸã ÿ®ŸÉ ŸÅŸä TestGenie ‚ú®\n\n"
            "üéØ ÿ£ÿØŸàÿßÿ™ ÿ™ÿπŸÑŸäŸÖŸäÿ© ÿ∞ŸÉŸäÿ©:\n"
            "- ÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™ ŸÖŸÜ ŸÖŸÑŸÅÿßÿ™ŸÉ\n"
            "- ÿ®ÿ∑ÿßŸÇÿßÿ™ ŸÖÿ±ÿßÿ¨ÿπÿ© (Anki)\n"
            "- ŸÖŸÑÿÆÿµÿßÿ™ PDF/Word\n"
            "- ÿ£ŸÑÿπÿßÿ® ÿ™ÿπŸÑŸäŸÖŸäÿ© *(ŸÇÿ±Ÿäÿ®Ÿãÿß)*\n\n"
            "üìå ŸÑÿØŸäŸÉ 3 ÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™ ŸÖÿ¨ÿßŸÜŸäÿ© ÿ¥Ÿáÿ±ŸäŸãÿß.\n\n"
            "ÿßÿÆÿ™ÿ± ŸÖÿß ŸäŸÜÿßÿ≥ÿ®ŸÉ üëá",
            chat_id=chat_id,
            message_id=message_id,
            reply_markup=keyboard
        )


    elif data == "change_specialty":
        keyboard = InlineKeyboardMarkup()
        buttons = [
            ("ü©∫ ÿßŸÑÿ∑ÿ®", "set_major_ÿßŸÑÿ∑ÿ®"),
            ("üõ†Ô∏è ÿßŸÑŸáŸÜÿØÿ≥ÿ©", "set_major_ÿßŸÑŸáŸÜÿØÿ≥ÿ©"),
            ("üíä ÿßŸÑÿµŸäÿØŸÑÿ©", "set_major_ÿßŸÑÿµŸäÿØŸÑÿ©"),
            ("üó£Ô∏è ÿßŸÑŸÑÿ∫ÿßÿ™", "set_major_ÿßŸÑŸÑÿ∫ÿßÿ™"),
            ("‚ùì ÿ∫Ÿäÿ± ÿ∞ŸÑŸÉ...", "set_major_custom"),
        ]
        for text, data_btn in buttons:
            keyboard.add(InlineKeyboardButton(text, callback_data=data_btn))
        keyboard.add(InlineKeyboardButton("‚¨ÖÔ∏è ÿ±ÿ¨Ÿàÿπ", callback_data="go_account_settings"))

        bot.edit_message_text(
            "üéì ÿßÿÆÿ™ÿ± ÿ™ÿÆÿµÿµŸÉ ŸÖŸÜ ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ© üëá", 
            chat_id=chat_id,
            message_id=message_id,
            reply_markup=keyboard
        )

    elif data.startswith("set_major_"):
        selected_major = data.replace("set_major_", "")
    
        if selected_major == "custom":
            user_states[uid] = "awaiting_custom_major"
            bot.edit_message_text(
                "üìù ŸÖŸÜ ŸÅÿ∂ŸÑŸÉ ÿ£ÿ±ÿ≥ŸÑ ÿ™ÿÆÿµÿµŸÉ ÿ®ÿØŸÇÿ© (ŸÖÿ´ÿßŸÑ: ÿ•ÿØÿßÿ±ÿ© ÿ£ÿπŸÖÿßŸÑÿå ÿ•ÿπŸÑÿßŸÖÿå ÿ•ŸÑÿÆ).",
                chat_id=chat_id,
                message_id=message_id
            )
            return
    
        # ÿ≠ŸÅÿ∏ ÿßŸÑÿ™ÿÆÿµÿµ ŸÅŸä ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
        save_user_major(uid, selected_major)

        # ÿ™ÿπÿØŸäŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÑÿ•ÿπŸÑÿßŸÖ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ´ŸÖ ÿ™ÿπÿØŸäŸÑŸáÿß ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ÿ®ÿπÿØ ÿ´ŸàÿßŸÜŸä ŸÑÿπÿ±ÿ∂ ÿßŸÑŸÇÿßÿ¶ŸÖÿ©
        bot.edit_message_text(
            f"‚úÖ ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿ™ÿÆÿµÿµŸÉ ÿ®ŸÜÿ¨ÿßÿ≠: *{selected_major}*\n\nÿ¨ÿßÿ±Ÿä ÿ™ÿ¨ŸáŸäÿ≤ ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©...",
            chat_id=chat_id,
            message_id=message_id,
            parse_mode="Markdown"
        )

    # ÿ•ÿπÿßÿØÿ© ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸàÿßÿ¨Ÿáÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ© ÿ®ÿπÿØ ÿ´ŸàÿßŸÜŸç
        time.sleep(2)  # ‚Üê ÿ™ÿ¨ŸÜÿ® ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ sleep ŸÅŸä ÿßŸÑÿ•ŸÜÿ™ÿßÿ¨ÿå ÿßŸÑÿ£ŸÅÿ∂ŸÑ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ job queue ÿ£Ÿà threading
        try:
            send_main_menu(chat_id, message_id)  # ÿ™ÿπÿØŸäŸÑ ŸÜŸÅÿ≥ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©
        except:
            pass  # ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑÿÆÿ∑ÿ£ ÿ•ÿ∞ÿß ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿ£Ÿà ÿ™ŸÖ ÿ™ÿπÿØŸäŸÑŸáÿß ŸÖÿ≥ÿ®ŸÇŸãÿß
        
    elif data.startswith("major_"):
        major_key = data.split("_", 1)[1]
        if major_key == "custom":
            user_states[uid] = "awaiting_major"
            bot.send_message(uid, "‚úèÔ∏è ŸÖŸÜ ŸÅÿ∂ŸÑŸÉ ÿ£ÿ±ÿ≥ŸÑ ÿßÿ≥ŸÖ ÿ™ÿÆÿµÿµŸÉ ÿ®ÿØŸÇÿ©.")
        else:
            cursor.execute("INSERT OR REPLACE INTO users(user_id, major) VALUES(?, ?)", (uid, major_key))
            conn.commit()
            bot.send_message(uid, f"‚úÖ ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿØ ÿ™ÿÆÿµÿµŸÉ: {major_key}\n"
                             "ÿßŸÑÿ¢ŸÜ ÿ£ÿ±ÿ≥ŸÑ ŸÖŸÑŸÅ (PDF/DOCX/TXT) ÿ£Ÿà ŸÜÿµŸãÿß ŸÖÿ®ÿßÿ¥ÿ±Ÿãÿß ŸÑÿ™ŸàŸÑŸäÿØ ÿßÿÆÿ™ÿ®ÿßÿ±ŸÉ.")
    
    elif data == "game_private":
        try:
            cursor.execute("SELECT major FROM users WHERE user_id = ?", (uid,))
            row = cursor.fetchone()
            major = row[0] if row else "ÿπÿßŸÖ"

            keyboard = InlineKeyboardMarkup(row_width=1)
            keyboard.add(
                InlineKeyboardButton("üß© Vocabulary Match", callback_data="game_vocab"),
                InlineKeyboardButton("‚è±Ô∏è ÿ™ÿ≠ÿØŸä ÿßŸÑÿ≥ÿ±ÿπÿ©", callback_data="game_speed"),
                InlineKeyboardButton("‚ùå ÿßŸÑÿ£ÿÆÿ∑ÿßÿ° ÿßŸÑÿ¥ÿßÿ¶ÿπÿ©", callback_data="game_mistakes"),
                InlineKeyboardButton("üß† ŸÑÿπÿ®ÿ© ÿßŸÑÿßÿ≥ÿ™ŸÜÿ™ÿßÿ¨", callback_data="game_inference"),
                InlineKeyboardButton("‚¨ÖÔ∏è ÿ±ÿ¨Ÿàÿπ", callback_data="go_games")
            )
            bot.edit_message_text(
                f"üéì ÿ™ÿÆÿµÿµŸÉ ÿßŸÑÿ≠ÿßŸÑŸä: {major}\n"
                "ÿßÿÆÿ™ÿ± ŸÑÿπÿ®ÿ© üëá",
                chat_id=chat_id,
                message_id=message_id,
                reply_markup=keyboard
            )
        except Exception as e:
            logging.exception("‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä game_private")
            bot.send_message(uid, "‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿπÿ±ÿ∂ ÿßŸÑÿ£ŸÑÿπÿßÿ®.")

    
    elif data == "back_to_games":
        try:
            bot.delete_message(c.message.chat.id, c.message.message_id)
        except Exception as e:
            logging.warning(f"‚ùå ŸÅÿ¥ŸÑ ÿ≠ÿ∞ŸÅ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿπŸÜÿØ ÿßŸÑÿ±ÿ¨Ÿàÿπ: {e}")
    
    

    elif data in ["game_vocab", "game_speed", "game_mistakes", "game_inference"]:
        game_type = data.split("_", 1)[1]

        # ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ•ŸÖŸÉÿßŸÜŸäÿ© ÿßŸÑŸÑÿπÿ® ÿßŸÑŸäŸàŸÖŸä (6 ŸÖÿ±ÿßÿ™)
        state = game_states.get(uid, {"count": 0})
        if state["count"] >= 6:
            return bot.send_message(uid, "üõë ŸÑŸÇÿØ ŸàÿµŸÑÿ™ ÿ•ŸÑŸâ ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸÑŸÑÿ£ŸÑÿπÿßÿ® ÿßŸÑŸÖÿ¨ÿßŸÜŸäÿ© (6 ŸÖÿ±ÿßÿ™).")

        if not can_play_game_today(uid, game_type):
            bot.answer_callback_query(c.id, "‚ùå ŸÑŸÇÿØ ŸÑÿπÿ®ÿ™ Ÿáÿ∞Ÿá ÿßŸÑŸÑÿπÿ®ÿ© ÿßŸÑŸäŸàŸÖ!")
            return

        loading_msg = bot.send_message(chat_id, "‚è≥ ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ÿ∂Ÿäÿ± ÿßŸÑÿ≥ÿ§ÿßŸÑ...")

        try:
            record_game_attempt(uid, game_type)

            # ÿßŸÑÿ™ÿÆÿµÿµ
            cursor.execute("SELECT major FROM users WHERE user_id=?", (uid,))
            row = cursor.fetchone()
            major = row[0] if row else "ÿπÿßŸÖ"

            # ÿ™ŸàŸÑŸäÿØ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿ≠ÿ≥ÿ® ŸÜŸàÿπ ÿßŸÑŸÑÿπÿ®ÿ©
            if game_type == "vocab":
                raw = generate_vocabulary_game(uid, major, native_lang="Arabic")
            elif game_type == "speed":
                raw = generate_speed_challenge(uid, major, native_lang="Arabic")
            elif game_type == "mistakes":
                raw = generate_common_mistakes_game(uid, major, native_lang="Arabic")
            elif game_type == "inference":
                raw = generate_inference_game(uid, major, native_lang="Arabic")

            question = raw["question"]
            options = raw["options"]
            correct_index = raw["correct_index"]

            if not isinstance(options, list) or len(options) < 2:
                raise ValueError("ÿπÿØÿØ ÿßŸÑÿÆŸäÿßÿ±ÿßÿ™ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠")

            # ÿ≠ŸÅÿ∏ ÿÆŸäÿßÿ±ÿßÿ™ ÿßŸÑÿ≥ÿ§ÿßŸÑ ŸÅŸä ÿßŸÑÿ∞ÿßŸÉÿ±ÿ© ÿßŸÑŸÖÿ§ŸÇÿ™ÿ©
            game_states[uid] = {"count": state["count"] + 1, "options": options}

            keyboard = InlineKeyboardMarkup(row_width=2)

            # ÿ£ÿ≤ÿ±ÿßÿ± ÿßŸÑÿ•ÿ¨ÿßÿ®ÿßÿ™
            for i, option in enumerate(options):
                short_option = (option[:50] + "...") if len(option) > 50 else option
                callback_data = f"ans_{game_type}_{i}_{correct_index}"
                keyboard.add(InlineKeyboardButton(short_option, callback_data=callback_data))
    
            # ÿ£ÿ≤ÿ±ÿßÿ± ÿßŸÑÿ™ÿ≠ŸÉŸÖ
            keyboard.row(
                InlineKeyboardButton("üîÑ ÿ≥ÿ§ÿßŸÑ ÿ¨ÿØŸäÿØ", callback_data=f"new_{game_type}"),
                InlineKeyboardButton("‚¨ÖÔ∏è ÿ±ÿ¨Ÿàÿπ", callback_data="back_to_games")
            )
            keyboard.add(
                InlineKeyboardButton(
                    "üì§ ÿ¥ÿßÿ±ŸÉ Ÿáÿ∞Ÿá ÿßŸÑŸÑÿπÿ®ÿ©", 
                    switch_inline_query="ÿ¨ÿ±ÿ® Ÿáÿ∞Ÿá ÿßŸÑŸÑÿπÿ®ÿ© ÿßŸÑÿ±ÿßÿ¶ÿπÿ© ŸÖŸÜ @Oiuhelper_bot üéØ")
            )

            bot.delete_message(chat_id, loading_msg.message_id)
            text = f"üß† ÿßÿÆÿ™ÿ± ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©:\n\n{question}"
            bot.send_message(chat_id, text, reply_markup=keyboard)

        except Exception as e:
            try:
                bot.delete_message(chat_id, loading_msg.message_id)
            except:
                pass
            logging.error(f"ŸÅÿ¥ŸÑ ÿ™ŸàŸÑŸäÿØ ÿßŸÑŸÑÿπÿ®ÿ©: {str(e)}")
            bot.send_message(uid, "‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ŸàŸÑŸäÿØ ÿßŸÑŸÑÿπÿ®ÿ©ÿå ÿ≠ÿßŸàŸÑ ŸÑÿßÿ≠ŸÇÿßŸã")

    # ŸÖÿπÿßŸÑÿ¨ÿ© ÿ∑ŸÑÿ® ÿ≥ÿ§ÿßŸÑ ÿ¨ÿØŸäÿØ
    


    elif data.startswith("new_"):
        game_type = data.split("_", 1)[1]

        # ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿπÿØÿØ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿßÿ™ (ŸÉŸÖÿß ŸÅŸä ÿßŸÑŸÇÿ≥ŸÖ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿä)
        state = game_states.get(uid, {"count": 0})
        if state["count"] >= 6:
            msg = random.choice([
                "üö´ ŸàÿµŸÑÿ™ ÿ•ŸÑŸâ ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸÑÿπÿØÿØ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑŸäŸàŸÖ!\n‚ú® ÿ¨ÿ±ÿ® ÿ∫ÿØŸãÿß ÿ£Ÿà ÿ¥ÿßÿ±ŸÉ ÿßŸÑÿ®Ÿàÿ™ ŸÖÿπ ÿ£ÿµÿØŸÇÿßÿ¶ŸÉ!",
                "‚ùå ÿßŸÜÿ™Ÿáÿ™ ŸÖÿ≠ÿßŸàŸÑÿßÿ™ ÿßŸÑŸäŸàŸÖ! ŸäŸÖŸÉŸÜŸÉ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ¨ÿØÿØŸãÿß ŸÑÿßÿ≠ŸÇŸãÿß.",
                "üõë ŸÑÿß ŸÖÿ≤ŸäÿØ ŸÖŸÜ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑÿ¢ŸÜ. ÿπÿØ ŸÑÿßÿ≠ŸÇŸãÿß ŸÑÿ™ŸÉŸÖŸÑ ÿ±ÿ≠ŸÑÿ™ŸÉ!"
            ])
            return bot.answer_callback_query(c.id, msg, show_alert=True)

        loading_msg = bot.send_message(c.message.chat.id, "‚è≥ ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ÿ∂Ÿäÿ± ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ™ÿßŸÑŸä...")

        try:
            # ÿ™ŸàŸÑŸäÿØ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ¨ÿØŸäÿØ
            cursor.execute("SELECT major FROM users WHERE user_id=?", (uid,))
            row = cursor.fetchone()
            major = row[0] if row else "ÿπÿßŸÖ"

            game_generators = {
                "vocab": generate_vocabulary_game,
                "speed": generate_speed_challenge,
                "mistakes": generate_common_mistakes_game,
                "inference": generate_inference_game
            }

            raw = game_generators[game_type](uid, major)
            question = raw["question"]
            options = raw["options"]
            correct_index = raw["correct_index"]

            if not isinstance(options, list) or len(options) < 2:
                raise ValueError("ÿπÿØÿØ ÿßŸÑÿÆŸäÿßÿ±ÿßÿ™ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠")

            # ÿ≠ŸÅÿ∏ ÿÆŸäÿßÿ±ÿßÿ™ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ¨ÿØŸäÿØ
            game_states[uid]["count"] += 1
            game_states[uid]["options"] = options

            # ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ£ÿ≤ÿ±ÿßÿ±
            keyboard = InlineKeyboardMarkup(row_width=2)
            for i, option in enumerate(options):
                short_option = (option[:50] + "...") if len(option) > 50 else option
                callback_data = f"ans_{game_type}_{i}_{correct_index}"
                keyboard.add(InlineKeyboardButton(short_option, callback_data=callback_data))

            keyboard.row(
                InlineKeyboardButton("üîÑ ÿ≥ÿ§ÿßŸÑ ÿ¨ÿØŸäÿØ", callback_data=f"new_{game_type}"),
                InlineKeyboardButton("‚¨ÖÔ∏è ÿ±ÿ¨Ÿàÿπ", callback_data="back_to_games")
            )
            keyboard.add(
                InlineKeyboardButton(
                    "üì§ ÿ¥ÿßÿ±ŸÉ Ÿáÿ∞Ÿá ÿßŸÑŸÑÿπÿ®ÿ©", 
                    switch_inline_query="ÿ¨ÿ±ÿ® Ÿáÿ∞Ÿá ÿßŸÑŸÑÿπÿ®ÿ© ÿßŸÑÿ±ÿßÿ¶ÿπÿ© ŸÖŸÜ @Oiuhelper_bot üéØ")
            )

            # ÿ™ÿπÿØŸäŸÑ ŸÜŸÅÿ≥ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©
            bot.edit_message_text(
                text=f"üß† ÿßÿÆÿ™ÿ± ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©:\n\n{question}",
                chat_id=c.message.chat.id,
                message_id=c.message.message_id,
                reply_markup=keyboard
            )

        except Exception as e:
            logging.error(f"‚ùå ŸÅÿ¥ŸÑ ÿ™ŸàŸÑŸäÿØ ÿ≥ÿ§ÿßŸÑ ÿ¨ÿØŸäÿØ: {e}")
            bot.answer_callback_query(c.id, "‚ùå ŸÅÿ¥ŸÑ ÿ™ŸàŸÑŸäÿØ ÿßŸÑÿ≥ÿ§ÿßŸÑ")

        finally:
            try:
                bot.delete_message(c.message.chat.id, loading_msg.message_id)
            except:
                pass

    elif data.startswith("ans_"):
        parts = data.split("_")
        game_type = parts[1]
        selected = int(parts[2])
        correct = int(parts[3])

        options = game_states.get(uid, {}).get("options", [])
        correct_text = options[correct] if correct < len(options) else f"ÿßŸÑÿÆŸäÿßÿ± ÿ±ŸÇŸÖ {correct+1}"

        wrong_responses = [
            "‚ùå ÿÆÿ∑ÿ£! ÿ¨ÿ±ÿ® ŸÖÿ¨ÿØÿØŸãÿß üòâ\n‚úÖ ÿßŸÑÿµÿ≠Ÿäÿ≠: {correct}",
            "üö´ ŸÑŸÑÿ£ÿ≥ŸÅÿå ŸÑŸäÿ≥ÿ™ ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©!\n‚úÖ ÿßŸÑÿ¨Ÿàÿßÿ®: {correct}",
            "üòÖ ŸÑŸäÿ≥ÿ™ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©ÿå ÿßŸÑÿ¨Ÿàÿßÿ® ŸáŸà: {correct}",
            "‚ùå ŸÑÿßÿå ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ!\n‚úîÔ∏è ÿßŸÑÿµÿ≠Ÿäÿ≠ ŸáŸà: {correct}"
        ]

        if selected == correct:
            bot.answer_callback_query(c.id, "‚úÖ ÿ•ÿ¨ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ©!", show_alert=False)
        else:
            msg = random.choice(wrong_responses).format(correct=correct_text)
            bot.answer_callback_query(c.id, msg, show_alert=False)
    
    elif data.startswith("soon_"):
        feature_name = {
            "soon_review": "üìö ŸÖŸäÿ≤ÿ© ÿßŸÑŸÖÿ±ÿßÿ¨ÿπÿ© ÿßŸÑÿ≥ÿ±Ÿäÿπÿ©",
            "soon_summary": "üìÑ ŸÖŸÑÿÆÿµÿßÿ™ PDF",
        }.get(data, "Ÿáÿ∞Ÿá ÿßŸÑŸÖŸäÿ≤ÿ©")

        bot.answer_callback_query(c.id)
        bot.send_message(chat_id, f"{feature_name} ÿ≥ÿ™ŸÉŸàŸÜ ŸÖÿ™ÿßÿ≠ÿ© ŸÇÿ±Ÿäÿ®Ÿãÿß... üöß")



@bot.message_handler(func=lambda m: user_states.get(m.from_user.id) == "awaiting_major", content_types=['text'])
def set_custom_major(msg):
    if msg.chat.type != "private":
        return  # ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ŸÅŸä ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™
    major = msg.text.strip()
    uid   = msg.from_user.id

    cursor.execute(
        "INSERT OR REPLACE INTO users(user_id, major) VALUES(?, ?)",
        (uid, major)
    )
    conn.commit()
    user_states.pop(uid, None)

    bot.send_message(uid,
        f"‚úÖ ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿ™ÿÆÿµÿµŸÉ: \"{major}\"\n"
        "ÿßŸÑÿ¢ŸÜ ÿ£ÿ±ÿ≥ŸÑ ŸÖŸÑŸÅ (PDF/DOCX/TXT) ÿ£Ÿà ŸÜÿµŸãÿß ŸÖÿ®ÿßÿ¥ÿ±Ÿãÿß ŸÑÿ™ŸàŸÑŸäÿØ ÿßÿÆÿ™ÿ®ÿßÿ±ŸÉ."
    )
    # notify admin
    bot.send_message(ADMIN_ID,
        f"üÜï ÿ™ÿÆÿµÿµ ÿ¨ÿØŸäÿØ ÿ£Ÿèÿ±ÿ≥ŸÑ ŸÖŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ:\n"
        f"üë§ @{msg.from_user.username or msg.from_user.id}\n"
        f"üìö ÿßŸÑÿ™ÿÆÿµÿµ: {major}"
        )
 
@bot.message_handler(func=lambda m: user_states.get(m.from_user.id) in [
    "awaiting_major",
    "awaiting_major_for_games",
    "awaiting_custom_major"
])
def handle_user_major(msg):
    if msg.chat.type != "private":
        return  # ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ŸÅŸä ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™

    uid = msg.from_user.id
    state = user_states.get(uid)
    major = msg.text.strip()

    if len(major) < 2:
        bot.send_message(uid, "‚ö†Ô∏è Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ÿ™ÿÆÿµÿµ ÿµÿßŸÑÿ≠.")
        return

    cursor.execute("INSERT OR REPLACE INTO users(user_id, major) VALUES(?, ?)", (uid, major))
    conn.commit()
    user_states.pop(uid, None)

    if state == "awaiting_major":
        bot.send_message(uid, f"‚úÖ ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿ™ÿÆÿµÿµŸÉ: {major}\n"
                              "ÿßŸÑÿ¢ŸÜ ÿ£ÿ±ÿ≥ŸÑ ŸÖŸÑŸÅ (PDF/DOCX/TXT) ÿ£Ÿà ŸÜÿµŸãÿß ŸÖÿ®ÿßÿ¥ÿ±Ÿãÿß ŸÑÿ™ŸàŸÑŸäÿØ ÿßÿÆÿ™ÿ®ÿßÿ±ŸÉ.")
        
    elif state == "awaiting_major_for_games":
        bot.send_message(uid, f"‚úÖ ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿ™ÿÆÿµÿµŸÉ: {major}\n"
                              "ÿßŸÑÿ¢ŸÜ ŸäŸÖŸÉŸÜŸÉ ÿßÿÆÿ™Ÿäÿßÿ± ŸÑÿπÿ®ÿ© ŸÖŸÜ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ£ŸÑÿπÿßÿ® ÿßŸÑÿ™ÿπŸÑŸäŸÖŸäÿ©.")
        keyboard = InlineKeyboardMarkup(row_width=1)
        keyboard.add(
            InlineKeyboardButton("üîí ÿßŸÑÿπÿ® ŸÅŸä ÿßŸÑÿÆÿßÿµ", callback_data="game_private"),
            InlineKeyboardButton("üë• ÿßŸÑÿπÿ® ŸÅŸä ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©", switch_inline_query="game")
        )
        bot.send_message(uid, "üéÆ ÿßÿÆÿ™ÿ± ÿ∑ÿ±ŸäŸÇÿ© ÿßŸÑŸÑÿπÿ®:", reply_markup=keyboard)

    elif state == "awaiting_custom_major":
        sent = bot.send_message(uid, f"‚úÖ ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿ™ÿÆÿµÿµŸÉ: *{major}*", parse_mode="Markdown")
        time.sleep(2)
        try:
            bot.edit_message_text(
                "‚¨áÔ∏è Ÿáÿ∞Ÿá ŸáŸä ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©:",
                chat_id=sent.chat.id,
                message_id=sent.message_id
            )
            send_main_menu(uid, message_id=sent.message_id)
        except:
            send_main_menu(uid)


@bot.message_handler(content_types=['text', 'document', 'photo'])
def unified_handler(msg):
    if msg.chat.type != "private":
        return

    uid = msg.from_user.id
    state = user_states.get(uid)

    # ÿßŸÑÿ™ÿÆÿµÿµ ŸÖŸÜ ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
    cursor.execute("SELECT major FROM users WHERE user_id = ?", (uid,))
    row = cursor.fetchone()
    major = row[0] if row else "General"

    content = ""
    path = ""

    try:
        # ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÜÿµ ŸÖÿ®ÿßÿ¥ÿ±ÿ©
        if msg.content_type == "text":
            content = msg.text

        # ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿµŸàÿ± (photo)
        elif msg.content_type == "photo":
            if not can_generate(uid):
                return bot.send_message(uid, "‚ö†Ô∏è Ÿáÿ∞Ÿá ÿßŸÑŸÖŸäÿ≤ÿ© ŸÖÿ™ÿßÿ≠ÿ© ŸÅŸÇÿ∑ ŸÑŸÑŸÖÿ¥ÿ™ÿ±ŸÉŸäŸÜ.")
            
            file_id = msg.photo[-1].file_id
            file_info = bot.get_file(file_id)
            file_data = bot.download_file(file_info.file_path)

            os.makedirs("downloads", exist_ok=True)
            path = os.path.join("downloads", f"{uid}_photo.jpg")
            with open(path, "wb") as f:
                f.write(file_data)

            bot.send_message(uid, "üñºÔ∏è ÿ¨ÿßÿ±Ÿä ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿßŸÑŸÜÿµ ŸÖŸÜ ÿßŸÑÿµŸàÿ±ÿ©...")

            content, ocr_debug = extract_text_with_ocr_space(path, api_key=OCR_API_KEY, language="eng")
            if not content.strip():
                return bot.send_message(uid, f"‚ùå ŸÅÿ¥ŸÑ ŸÅŸä ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿßŸÑŸÜÿµ ŸÖŸÜ ÿßŸÑÿµŸàÿ±ÿ©. {ocr_debug}")


        elif msg.content_type == "document":
            file_info = bot.get_file(msg.document.file_id)
            if file_info.file_size > 5 * 1024 * 1024:
                return bot.send_message(uid, "‚ùå ÿßŸÑŸÖŸÑŸÅ ŸÉÿ®Ÿäÿ± ÿ¨ÿØŸãÿßÿå ÿßŸÑÿ≠ÿØ 5 ŸÖŸäÿ∫ÿßÿ®ÿßŸäÿ™.")
    
            file_data = bot.download_file(file_info.file_path)
            os.makedirs("downloads", exist_ok=True)
            path = os.path.join("downloads", msg.document.file_name)

            with open(path, "wb") as f:
                f.write(file_data)

            ext = path.rsplit(".", 1)[-1].lower()
            # ÿ®ÿπÿØ ÿßŸÑÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿßŸÑÿπÿßÿØŸä
            if ext == "pdf":
                content = extract_text_from_pdf(path)
                # ÿ•ÿ∞ÿß ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ∫Ÿäÿ± ŸÖÿ¥ÿ™ÿ±ŸÉÿå ÿßŸÇÿ™ÿ∑ÿπ ŸÅŸÇÿ∑ 3000 ÿ≠ÿ±ŸÅ
                if not can_generate(uid):
                    content = content[:3000]
                if is_text_empty(content):
                    if not can_generate(uid):
                        return bot.send_message(uid, "‚ö†Ô∏è ŸÑÿß ŸäŸÖŸÉŸÜ ŸÇÿ±ÿßÿ°ÿ© Ÿáÿ∞ÿß ÿßŸÑŸÖŸÑŸÅ ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß. ÿ™ÿ™ÿ∑ŸÑÿ® ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÖÿ™ŸÇÿØŸÖÿ© ÿßÿ¥ÿ™ÿ±ÿßŸÉŸãÿß ŸÅÿπÿßŸÑŸãÿß.")
                    bot.send_message(uid, "‚è≥ Ÿäÿ™ŸÖ ÿ™ÿ¨ŸáŸäÿ≤ ÿßŸÑŸÖŸÑŸÅ... ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ± ŸÑÿ≠ÿ∏ÿßÿ™.")
                    language = detect_language_from_filename(msg.document.file_name)
                    content, ocr_debug = extract_text_with_ocr_space(path, api_key=OCR_API_KEY, language=language)
                    if not content.strip():
                        bot.send_message(uid, f"‚ùå ŸÅÿ¥ŸÑ ŸÅŸä ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿßŸÑŸÜÿµ ŸÖŸÜ ÿßŸÑŸÖŸÑŸÅ. {ocr_debug}")
                        return

                    # ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÜÿµ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿ±ÿ¨ ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ‚Äî ‚ö†Ô∏è ŸäŸèŸÅÿ∂ŸÑ ŸÅŸÇÿ∑ ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿ≠ÿ¨ŸÖŸá ÿµÿ∫Ÿäÿ±Ÿãÿß
                    preview = content[:1500]
                    bot.send_message(uid, f"üìÑ ÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿßŸÑŸÜÿµ ÿ®ŸÜÿ¨ÿßÿ≠ (ÿ¨ÿ≤ÿ° ŸÖŸÜŸá):\n\n{preview}")
            elif ext == "docx":
                content = extract_text_from_docx(path)
                # ÿ•ÿ∞ÿß ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ∫Ÿäÿ± ŸÖÿ¥ÿ™ÿ±ŸÉÿå ÿßŸÇÿ™ÿ∑ÿπ ŸÅŸÇÿ∑ 3000 ÿ≠ÿ±ŸÅ
                if not can_generate(uid):
                    content = content[:3000]
                if is_text_empty(content):
                    if not can_generate(uid):
                        return bot.send_message(uid, "‚ö†Ô∏è ŸÑÿß ŸäŸÖŸÉŸÜ ŸÇÿ±ÿßÿ°ÿ© Ÿáÿ∞ÿß ÿßŸÑŸÖŸÑŸÅ ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß. ÿ™ÿ™ÿ∑ŸÑÿ® ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÖÿ™ŸÇÿØŸÖÿ© ÿßÿ¥ÿ™ÿ±ÿßŸÉŸãÿß ŸÅÿπÿßŸÑŸãÿß.")
                    bot.send_message(uid, "‚è≥ Ÿäÿ™ŸÖ ÿ™ÿ¨ŸáŸäÿ≤ ÿßŸÑŸÖŸÑŸÅ... ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ± ŸÑÿ≠ÿ∏ÿßÿ™.")
                    language = detect_language_from_filename(msg.document.file_name)
                    content = extract_text_with_ocr_space(path, api_key=OCR_API_KEY, language=language)
            elif ext == "txt":
                content = extract_text_from_txt(path)
                # ÿ•ÿ∞ÿß ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ∫Ÿäÿ± ŸÖÿ¥ÿ™ÿ±ŸÉÿå ÿßŸÇÿ™ÿ∑ÿπ ŸÅŸÇÿ∑ 3000 ÿ≠ÿ±ŸÅ
                if not can_generate(uid):
                    content = content[:3000]
                if is_text_empty(content):
                    if not can_generate(uid):
                        return bot.send_message(uid, "‚ö†Ô∏è ŸÑÿß ŸäŸÖŸÉŸÜ ŸÇÿ±ÿßÿ°ÿ© Ÿáÿ∞ÿß ÿßŸÑŸÖŸÑŸÅ ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß. ÿ™ÿ™ÿ∑ŸÑÿ® ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÖÿ™ŸÇÿØŸÖÿ© ÿßÿ¥ÿ™ÿ±ÿßŸÉŸãÿß ŸÅÿπÿßŸÑŸãÿß.")
                    bot.send_message(uid, "‚è≥ Ÿäÿ™ŸÖ ÿ™ÿ¨ŸáŸäÿ≤ ÿßŸÑŸÖŸÑŸÅ... ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ± ŸÑÿ≠ÿ∏ÿßÿ™.")
                    content = extract_text_with_ocr_space(path, api_key=OCR_API_KEY, language="eng+ara")
                
            elif ext == "pptx":
                content = extract_text_from_pptx(path)
            
                # ÿ•ÿ∞ÿß ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ∫Ÿäÿ± ŸÖÿ¥ÿ™ÿ±ŸÉÿå ÿßŸÇÿ™ÿ∑ÿπ ŸÅŸÇÿ∑ 3000 ÿ≠ÿ±ŸÅ
                if not can_generate(uid):
                    content = content[:3000]
                
                if is_text_empty(content):
                    if not can_generate(uid):
                        return bot.send_message(uid, "‚ö†Ô∏è ŸÑÿß ŸäŸÖŸÉŸÜ ŸÇÿ±ÿßÿ°ÿ© Ÿáÿ∞ÿß ÿßŸÑŸÖŸÑŸÅ ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß. ÿ™ÿ™ÿ∑ŸÑÿ® ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÖÿ™ŸÇÿØŸÖÿ© ÿßÿ¥ÿ™ÿ±ÿßŸÉŸãÿß ŸÅÿπÿßŸÑŸãÿß.")
                    bot.send_message(uid, "‚è≥ Ÿäÿ™ŸÖ ÿ™ÿ¨ŸáŸäÿ≤ ÿßŸÑŸÖŸÑŸÅ... ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ± ŸÑÿ≠ÿ∏ÿßÿ™.")
                    language = detect_language_from_filename(msg.document.file_name)
                    content = extract_text_with_ocr_space(path, api_key=OCR_API_KEY, language=language)

            elif ext in ("jpg", "png"):
                if not can_generate(uid):
                    return bot.send_message(uid, "‚ö†Ô∏è Ÿáÿ∞Ÿá ÿßŸÑŸÖŸäÿ≤ÿ© ŸÖÿ™ÿßÿ≠ÿ© ŸÅŸÇÿ∑ ŸÑŸÑŸÖÿ¥ÿ™ÿ±ŸÉŸäŸÜ.")
                bot.send_message(uid, "‚è≥ ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿµŸàÿ±ÿ©...")
                content, ocr_debug = extract_text_with_ocr_space(path, api_key=OCR_API_KEY, language="eng")
            
               
            else:
                return bot.send_message(uid, "‚ö†Ô∏è ŸÜŸàÿπ ÿßŸÑŸÖŸÑŸÅ ÿ∫Ÿäÿ± ŸÖÿØÿπŸàŸÖ. ÿ£ÿ±ÿ≥ŸÑ PDF ÿ£Ÿà Word ÿ£Ÿà TXT.")
  
        else:
            try:
                os.remove(path)
            except Exception as e:
                print(f"[WARNING] ŸÑŸÖ Ÿäÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖŸÑŸÅ ÿßŸÑŸÖÿ§ŸÇÿ™: {e}")

        if not content or not content.strip():
            return bot.send_message(uid, "‚ö†Ô∏è ŸÑŸÖ ÿ£ÿ™ŸÖŸÉŸÜ ŸÖŸÜ ŸÇÿ±ÿßÿ°ÿ© ŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑŸÖŸÑŸÅ ÿ£Ÿà ÿßŸÑŸÜÿµ.")
        print(f">>> Content preview: {content[:300]}")

        waiting_messages_anki = [
            "üß† Ÿäÿ™ŸÖ ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÜÿµ ŸÑÿßÿ≥ÿ™ÿÆŸÑÿßÿµ ÿßŸÑŸÜŸÇÿßÿ∑ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ©...",
            "‚ú® ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿ•ŸÑŸâ ÿ®ÿ∑ÿßŸÇÿßÿ™ ÿ∞ŸÉŸäÿ© ÿ≥ŸáŸÑÿ© ÿßŸÑŸÖÿ±ÿßÿ¨ÿπÿ©...",
            "üìö ÿ™ŸÜÿ∏ŸäŸÖ ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™ ŸÑÿ™ÿπÿ≤Ÿäÿ≤ ŸÇÿØÿ±ÿ™ŸÉ ÿπŸÑŸâ ÿßŸÑÿ™ÿ∞ŸÉÿ±...",
            "üé® ÿ™ÿµŸÖŸäŸÖ ÿßŸÑÿ®ÿ∑ÿßŸÇÿßÿ™ ÿ®ÿ£ÿ≥ŸÑŸàÿ® Ÿäÿ≥ÿßÿπÿØ ÿπŸÑŸâ ÿßŸÑÿ™ÿπŸÑŸÖ ÿßŸÑÿ≥ÿ±Ÿäÿπ...",
            "‚öôÔ∏è ÿ•ÿπÿØÿßÿØ ÿßŸÑÿ®ÿ∑ÿßŸÇÿßÿ™ ŸÑÿ™ŸÉŸàŸÜ ÿ¨ÿßŸáÿ≤ÿ© ŸÑŸÑŸÖÿ±ÿßÿ¨ÿπÿ© ÿßŸÑŸÅÿπÿßŸÑÿ©...",
            "üîç ÿßŸÑÿ™ÿ±ŸÉŸäÿ≤ ÿπŸÑŸâ ÿßŸÑŸÖŸÅÿßŸáŸäŸÖ ÿßŸÑÿ¨ŸàŸáÿ±Ÿäÿ© ŸÑÿ®ŸÜÿßÿ° ÿ£ÿ≥ÿßÿ≥ ŸÇŸàŸä...",
            "üöÄ ÿ™ÿ≠ÿ≥ŸäŸÜ ŸáŸäŸÉŸÑ ÿßŸÑÿ®ÿ∑ÿßŸÇÿßÿ™ ŸÑÿ™ÿ¨ÿ±ÿ®ÿ© ÿØÿ±ÿßÿ≥Ÿäÿ© ÿ≥ŸÑÿ≥ÿ©...",
            "üí° ÿ¨ÿßÿ±Ÿä ÿµŸäÿßÿ∫ÿ© ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ŸàÿßŸÑÿ£ÿ¨Ÿàÿ®ÿ© ÿ®Ÿàÿ∂Ÿàÿ≠ ŸàÿØŸÇÿ©..."
        ]


        waiting_messages_quiz = [
            "üìù ÿ¨ÿßÿ±Ÿä ÿµŸäÿßÿ∫ÿ© ÿ£ÿ≥ÿ¶ŸÑÿ© ÿØŸÇŸäŸÇÿ© ŸÖŸÜ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑŸÖŸÇÿØŸÖ...",
            "üéØ ÿ™ÿ≠ÿØŸäÿØ ÿ£ŸáŸÖ ÿßŸÑÿ£ŸÅŸÉÿßÿ± ŸÑŸàÿ∂ÿπ ÿ£ÿ≥ÿ¶ŸÑÿ© ÿ™ŸÇŸäÿ≥ ÿßŸÑŸÅŸáŸÖ ÿßŸÑÿ≠ŸÇŸäŸÇŸä...",
            "‚öñÔ∏è ŸÖŸàÿßÿ≤ŸÜÿ© ÿ£ŸÜŸàÿßÿπ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ŸÑÿ™ÿ∫ÿ∑Ÿäÿ© ÿ¥ÿßŸÖŸÑÿ© ŸÑŸÑŸÖŸàÿ∂Ÿàÿπ...",
            "üß† ÿ™ÿµŸÖŸäŸÖ ÿßÿÆÿ™ÿ®ÿßÿ± ÿ∞ŸÉŸä Ÿäÿ™ÿ≠ÿØŸâ ŸÖÿπÿ±ŸÅÿ™ŸÉ ÿ®ÿ¥ŸÉŸÑ ÿ®ŸÜŸëÿßÿ°...",
            "üìä ÿ™ŸÜÿ∏ŸäŸÖ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ŸÑÿ™ŸÇÿØŸäŸÖ ÿ™ŸÇŸäŸäŸÖ ŸÖÿ™ŸÉÿßŸÖŸÑ ŸÑŸÖÿ≥ÿ™ŸàÿßŸÉ...",
            "üß© ÿ®ŸÜÿßÿ° ÿßÿÆÿ™ÿ®ÿßÿ± ŸÖÿ™ŸÖÿßÿ≥ŸÉ ŸäŸÇŸäÿ≥ ŸÖÿÆÿ™ŸÑŸÅ ÿ¨ŸàÿßŸÜÿ® ÿßŸÑŸÖÿπÿ±ŸÅÿ©...",
            "üîç ŸÅÿ≠ÿµ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿ®ÿπŸÜÿßŸäÿ© ŸÑÿµŸäÿßÿ∫ÿ© ÿ£ÿ≥ÿ¶ŸÑÿ© ŸÖÿ≠ŸÉŸÖÿ©...",
            "‚úÖ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ¨ŸàÿØÿ© ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ŸÑÿ∂ŸÖÿßŸÜ ÿßÿÆÿ™ÿ®ÿßÿ± ÿπÿßÿØŸÑ..."
        ]


        progress_messages = [
            "‚è≥ ŸÑÿ≠ÿ∏ÿßÿ™ ŸàŸÜÿ®ÿØÿ£... 25% ŸÖŸÜ ÿßŸÑÿ∑ÿ±ŸäŸÇ",
            "‚ö°Ô∏è ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ© ŸÅŸä ŸÖŸÜÿ™ÿµŸÅŸáÿß... 50% ŸÖŸÜ ÿßŸÑÿ∑ÿ±ŸäŸÇ",
            "üöÄ ÿßŸÇÿ™ÿ±ÿ®ŸÜÿß ŸÖŸÜ ÿßŸÑÿ•ŸÜÿ¨ÿßÿ≤... 75% ŸÖŸÜ ÿßŸÑÿ∑ÿ±ŸäŸÇ",
            "üéâ ÿßŸÑŸÑŸÖÿ≥ÿßÿ™ ÿßŸÑÿ£ÿÆŸäÿ±ÿ©... 90% ŸÖŸÜ ÿßŸÑÿ∑ÿ±ŸäŸÇ"
        ]

        if state == "awaiting_anki_file":
            user_states.pop(uid, None)
    
            # ÿ•ÿπÿØÿßÿØ ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ£ŸàŸÑŸäÿ©
            loading_msg = bot.send_message(uid, "üîÑ ÿ¨ÿßÿ±Ÿä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÖŸÑŸÅ...")
    
            try:
                # ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ŸÉÿ®Ÿäÿ±ÿßŸã
                if len(content) > 10000:
                    try:
                        # ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÑÿπŸÖŸÑŸäÿ© ÿßŸÑÿ™ŸÑÿÆŸäÿµ
                        bot.edit_message_text(
                            chat_id=uid,
                            message_id=loading_msg.message_id,
                            text="üìö ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ŸÉÿ®Ÿäÿ± ÿ¨ÿØÿßŸã\nüîç ÿ¨ÿßÿ±Ÿä ÿ™ŸÑÿÆŸäÿµ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ..."
                        )
                
                        content = summarize_long_text(content)
                
                        # ÿ™ÿ£ŸÉŸäÿØ ŸÜÿ¨ÿßÿ≠ ÿßŸÑÿ™ŸÑÿÆŸäÿµ
                        bot.edit_message_text(
                            chat_id=uid,
                            message_id=loading_msg.message_id,
                            text="‚úÖ ÿ™ŸÖ ÿ™ŸÑÿÆŸäÿµ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿ®ŸÜÿ¨ÿßÿ≠\n‚è≥ ÿ¨ÿßÿ±Ÿä ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ®ÿ∑ÿßŸÇÿßÿ™..."
                        )
                        time.sleep(1)
                
                    except Exception as e:
                        print("[ERROR] ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ŸÑÿÆŸäÿµ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ:", e)
                        return bot.edit_message_text(
                            chat_id=uid,
                            message_id=loading_msg.message_id,
                            text="‚ùå ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ŸÑÿÆŸäÿµ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ.\n\nŸäÿ±ÿ¨Ÿâ ÿ•ÿ±ÿ≥ÿßŸÑ ŸÖŸÑŸÅ ÿ£ÿµÿ∫ÿ± ÿ£Ÿà ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÑÿßÿ≠ŸÇÿßŸã."
                        )
        
                # ŸÖÿ§ÿ¥ÿ± ÿ™ŸÇÿØŸÖ ŸÖÿ™ÿ≠ÿ±ŸÉ
                progress_phrases = [
                    "üìñ ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ...",
                    "üß† ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™...",
                    "üõ†Ô∏è ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ®ÿ∑ÿßŸÇÿßÿ™...",
                    "‚ú® ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑŸÜŸáÿßÿ¶Ÿä..."
                ]
        
                for i, phrase in enumerate(progress_phrases):
                    # ÿ•ÿ∂ÿßŸÅÿ© ÿ¥ÿ±Ÿäÿ∑ ÿ™ŸÇÿØŸÖ ÿ®ÿµÿ±Ÿä
                    progress_bar = "[" + "=" * (i+1) + " " * (len(progress_phrases)-i-1) + "]"
            
                    bot.edit_message_text(
                        chat_id=uid,
                        message_id=loading_msg.message_id,
                        text=f"{progress_bar}\n\n{phrase}\n\n‚è≥ Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±..."
                    )
                    time.sleep(1.5)
        
                # ÿ•ÿ∂ÿßŸÅÿ© ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÜÿ™ÿ∏ÿßÿ± ÿ¨ÿ∞ÿßÿ®ÿ©
                bot.edit_message_text(
                    chat_id=uid,
                    message_id=loading_msg.message_id,
                    text=f"üéØ {random.choice(waiting_messages_anki)}\n\n‚ö° ÿ¨ÿßÿ±Ÿä ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ≠ÿ∂Ÿäÿ±..."
                )
                time.sleep(2)
        
                # ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ®ÿ∑ÿßŸÇÿßÿ™
                cards, title = generate_anki_cards_from_text(content, major=major, user_id=uid)
        
                if not cards:
                    return bot.edit_message_text(
                        chat_id=uid,
                        message_id=loading_msg.message_id,
                        text="‚ùå ŸÑŸÖ ÿ£ÿ™ŸÖŸÉŸÜ ŸÖŸÜ ÿ•ŸÜÿ¥ÿßÿ° ÿ£Ÿä ÿ®ÿ∑ÿßŸÇÿßÿ™.\n\nŸÇÿØ ŸäŸÉŸàŸÜ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿ∫Ÿäÿ± ŸÖŸÜÿßÿ≥ÿ® ÿ£Ÿà ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©."
                    )
        
                # ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿπŸÜŸàÿßŸÜ ŸÑŸäŸÉŸàŸÜ ÿßÿ≥ŸÖ ŸÖŸÑŸÅ ÿµÿßŸÑÿ≠
                safe_title = re.sub(r'[^a-zA-Z0-9_\u0600-\u06FF]', '_', title)[:40]
                filename = f"{safe_title}_{uid}.apkg"
        
                # ÿ≠ŸÅÿ∏ ÿßŸÑŸÖŸÑŸÅ Ÿàÿ•ÿ±ÿ≥ÿßŸÑŸá ŸÖÿπ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ≥ÿßÿ®ŸÇÿ©
                filepath = save_cards_to_apkg(cards, filename=filename, deck_name=title)
        
                 # ÿ™ÿ≠ÿ±Ÿäÿ± ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ£ÿÆŸäÿ±ÿ© ŸÑÿ•ÿ∏Ÿáÿßÿ± ŸÜÿ¨ÿßÿ≠ ÿßŸÑÿπŸÖŸÑŸäÿ©
                bot.edit_message_text(
                    chat_id=uid,
                    message_id=loading_msg.message_id,
                    text=f"‚úÖ ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° {len(cards)} ÿ®ÿ∑ÿßŸÇÿ© ÿ®ŸÜÿ¨ÿßÿ≠!\n\nüìö ÿßŸÑÿπŸÜŸàÿßŸÜ: {title}\n\n‚ö° ÿ¨ÿßÿ±Ÿä ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÖŸÑŸÅ..."
                )
        
                # ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÖŸÑŸÅ ŸÖÿπ caption
                with open(filepath, 'rb') as file:
                    bot.send_document(
                        chat_id=uid,
                        document=file,
                        caption=f"üìÇ {title}\n\nüé¥ ÿπÿØÿØ ÿßŸÑÿ®ÿ∑ÿßŸÇÿßÿ™: {len(cards)}\n\nÿßÿ≥ÿ™ŸÖÿ™ÿπ ÿ®ÿßŸÑÿØÿ±ÿßÿ≥ÿ©!",
                        reply_to_message_id=loading_msg.message_id
                    )
        
                # ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ™ŸÇŸäŸäŸÖ (ÿ®ŸÜÿ≥ÿ®ÿ© 25% ÿ£Ÿà ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿ£ŸàŸÑ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ)
                if random.random() < 0.25 or usage_count.get(uid, 0) == 1:
                    rating_markup = types.InlineKeyboardMarkup()
                    rating_markup.row(
                        types.InlineKeyboardButton("‚≠ê 1", callback_data="rate_1"),
                        types.InlineKeyboardButton("‚≠ê 2", callback_data="rate_2"),
                        types.InlineKeyboardButton("‚≠ê 3", callback_data="rate_3")
                    )
                    rating_markup.row(
                        types.InlineKeyboardButton("‚≠ê 4", callback_data="rate_4"),
                        types.InlineKeyboardButton("‚≠ê 5", callback_data="rate_5"),
                        types.InlineKeyboardButton("ÿ™ÿ¨ÿßŸáŸÑ", callback_data="rate_ignore")
                    )
            
                    bot.send_message(
                        uid,
                        "‚ú® ŸÉŸäŸÅ ŸÉÿßŸÜÿ™ ÿ™ÿ¨ÿ±ÿ®ÿ™ŸÉ ŸÖÿπ ÿßŸÑÿ®Ÿàÿ™ÿü\n\nÿßÿÆÿ™ÿ± ÿπÿØÿØ ÿßŸÑŸÜÿ¨ŸàŸÖ ŸÑŸÑÿ™ŸÇŸäŸäŸÖ:",
                        reply_markup=rating_markup,
                        reply_to_message_id=sent_msg.message_id
                    )
        
                usage_count[uid] = usage_count.get(uid, 0) + 1

            except Exception as e:
                print("[ERROR] ŸÅÿ¥ŸÑ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÖŸÑŸÅ:", e)
                
        # ÿßŸÑÿ≠ÿßŸÑÿ© ÿßŸÑÿπÿßÿØŸäÿ©: ÿ™ŸàŸÑŸäÿØ ÿßÿÆÿ™ÿ®ÿßÿ±
        else:
            if not can_generate(uid):
                return bot.send_message(uid, "‚ö†Ô∏è ŸÑŸÇÿØ ÿßÿ≥ÿ™ŸÜŸÅÿØÿ™ 3 ÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™ ŸÖÿ¨ÿßŸÜŸäÿ© Ÿáÿ∞ÿß ÿßŸÑÿ¥Ÿáÿ±.")

            if len(content) > 10000:
                msg = bot.send_message(uid, "üîç ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ŸÉÿ®Ÿäÿ±ÿå ÿ¨ÿßÿ±Ÿä ÿ™ŸÑÿÆŸäÿµŸá ŸÑÿ™ŸàŸÑŸäÿØ ÿßÿÆÿ™ÿ®ÿßÿ±...")
                try:
                    content = summarize_long_text(content)
                except Exception as e:
                    print("[ERROR] ÿ™ŸÑÿÆŸäÿµ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ŸÅÿ¥ŸÑ:", e)
                    return bot.edit_message_text(chat_id=uid, message_id=msg.message_id,
                                         text="‚ùå ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ŸÑÿÆŸäÿµ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ. ÿ£ÿ±ÿ≥ŸÑ ŸÖŸÑŸÅŸãÿß ÿ£ÿµÿ∫ÿ± ÿ£Ÿà ÿ≠ÿßŸàŸÑ ŸÑÿßÿ≠ŸÇŸãÿß.")

                bot.edit_message_text(chat_id=uid, message_id=msg.message_id,
                              text="üß† ÿ¨ÿßÿ±Ÿä ÿ™ŸàŸÑŸäÿØ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±ÿå ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±...")
                time.sleep(1.5)
                for progress_msg in progress_messages:
                    bot.edit_message_text(chat_id=uid, message_id=msg.message_id, text=progress_msg)
                    time.sleep(1.5)
                bot.edit_message_text(chat_id=uid, message_id=msg.message_id,
                         text=random.choice(waiting_messages_quiz))
                time.sleep(2)
            else:
                msg = bot.send_message(uid, "üß† ÿ¨ÿßÿ±Ÿä ÿ™ŸàŸÑŸäÿØ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±ÿå ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±...")
                time.sleep(1.5)
                for progress_msg in progress_messages:
                    bot.edit_message_text(chat_id=uid, message_id=msg.message_id, text=progress_msg)
                    time.sleep(1.5)
                bot.edit_message_text(chat_id=uid, message_id=msg.message_id,
                         text=random.choice(waiting_messages_quiz))
                time.sleep(2)

            quizzes = generate_quizzes_from_text(content, major=major, user_id=uid, num_quizzes=10)
        
            if isinstance(quizzes, list) and len(quizzes) > 0:
                send_quizzes_as_polls(uid, quizzes, message_id=msg.message_id)
                increment_count(uid)
                try:
                    quiz_code = generate_quiz_code()
                    store_user_quiz(uid, quizzes, quiz_code)
            
                    # ÿ•ŸÜÿ¥ÿßÿ° ÿ£ÿ≤ÿ±ÿßÿ± ÿßŸÑŸÖÿ¥ÿßÿ±ŸÉÿ© ŸàÿßŸÑÿ±ÿ¨Ÿàÿπ
                    keyboard = types.InlineKeyboardMarkup()
                    keyboard.add(
                        types.InlineKeyboardButton("üëç ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑŸÇÿßÿ¶ŸÖÿ©", callback_data="go_home"),
                        types.InlineKeyboardButton("ü§ù ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±", url=f"https://t.me/Oiuhelper_bot?start={quiz_code}")
                    )
            
                    # ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÜŸáÿßŸäÿ© ŸÖÿπ ÿßŸÑÿ£ÿ≤ÿ±ÿßÿ±
                    bot.send_message(
                        chat_id,
                        "üéâ ÿßŸÜÿ™ŸáŸâ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±! ÿ®ÿßŸÑÿ™ŸàŸÅŸäŸÇ.\n\nüßæ Ÿáÿ∞ÿß ŸáŸà ÿßÿÆÿ™ÿ®ÿßÿ±ŸÉ ÿßŸÑÿ¥ÿÆÿµŸä.\nÿßÿÆÿ™ÿ± ÿ£ÿ≠ÿØ ÿßŸÑÿÆŸäÿßÿ±ÿßÿ™ ÿßŸÑÿ™ÿßŸÑŸäÿ© üëá",
                        reply_markup=keyboard
                    )
            
                except Exception as db_error:
                    print(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ± ÿ£Ÿà ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÜŸáÿßÿ¶Ÿäÿ©: {db_error}")
                    bot.send_message(chat_id, "üéâ ÿßŸÜÿ™ŸáŸâ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±! ÿ®ÿßŸÑÿ™ŸàŸÅŸäŸÇ.")
            
            else:
                print("[ERROR] Failed to generate valid quizzes:", quizzes)
                bot.send_message(uid, "‚ùå ŸÅÿ¥ŸÑ ÿ™ŸàŸÑŸäÿØ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±. ÿ≠ÿßŸàŸÑ ŸÑÿßÿ≠ŸÇŸãÿß.")

    finally:
        # ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖŸÑŸÅ ÿßŸÑŸÖÿ§ŸÇÿ™ ÿ•ŸÜ ŸàŸèÿ¨ÿØ
        if path and os.path.exists(path):
            try:
                os.remove(path)
            except Exception as e:
                print(f"[WARNING] ŸÑŸÖ Ÿäÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖŸÑŸÅ ÿßŸÑŸÖÿ§ŸÇÿ™: {e}")


known_channels = set()

@bot.channel_post_handler(func=lambda msg: True)
def handle_channel_post(msg):
    channel_id = msg.chat.id

    if channel_id in known_channels:
        return  # ÿ™ŸÖ ŸÖÿπÿßŸÑÿ¨ÿ™Ÿá ŸÖŸÜ ŸÇÿ®ŸÑ

    known_channels.add(channel_id)

    try:
        bot.send_message(
            ADMIN_ID,
            f"üì¢ ÿ™ŸÖ ÿßŸÉÿ™ÿ¥ÿßŸÅ ŸÇŸÜÿßÿ© ÿ¨ÿØŸäÿØÿ©:\n\n"
            f"*ÿßŸÑÿßÿ≥ŸÖ:* {msg.chat.title}\n"
            f"*ID:* `{channel_id}`",
            parse_mode="Markdown"
        )
    except Exception as e:
        print(f"[ERROR] ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÖÿπÿ±ŸÅ ŸÅÿ¥ŸÑ: {e}")


# -------------------------------------------------------------------
#                   inference handler
# -------------------------------------------------------------------


@bot.message_handler(commands=['submit_inference'])
def handle_submit_inference(msg):
    if msg.chat.type != "private":
        return  # ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ŸÅŸä ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™
    uid = msg.from_user.id
    user_states[uid] = {"state": "awaiting_inference_question", "temp": {}}
    bot.send_message(uid, "üß† ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑÿ¢ŸÜ ÿ≥ŸäŸÜÿßÿ±ŸäŸà ÿ£Ÿà ÿ≥ÿ§ÿßŸÑŸãÿß ŸÑŸÑÿßÿπÿ®ŸäŸÜ (ŸÖÿ´ÿßŸÑ: ŸÉŸäŸÅ ÿ™ÿ™ÿµÿ±ŸÅ ŸÅŸä Ÿáÿ∞ÿß ÿßŸÑŸÖŸàŸÇŸÅÿü)")

@bot.message_handler(func=lambda m: user_states.get(m.from_user.id, {}).get("state") in [
    "awaiting_inference_question", "awaiting_inference_options", "awaiting_inference_correct"])
def handle_inference_submission(msg):
    if msg.hat.type != "private":
        return  # ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ŸÅŸä ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™
    uid = msg.from_user.id
    state = user_states.get(uid, {})
    temp = state.get("temp", {})

    if state["state"] == "awaiting_inference_question":
        temp["question"] = msg.text.strip()
        user_states[uid] = {"state": "awaiting_inference_options", "temp": temp}
        bot.send_message(uid, "‚úèÔ∏è ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑÿ¢ŸÜ 4 ÿÆŸäÿßÿ±ÿßÿ™ÿå ŸÉŸÑ ÿÆŸäÿßÿ± ŸÅŸä ÿ≥ÿ∑ÿ± ŸÖŸÜŸÅÿµŸÑ.")

    elif state["state"] == "awaiting_inference_options":
        options = msg.text.strip().split("\n")
        if len(options) != 4:
            return bot.send_message(uid, "‚ö†Ô∏è Ÿäÿ¨ÿ® ÿ£ŸÜ ÿ™ÿ±ÿ≥ŸÑ 4 ÿÆŸäÿßÿ±ÿßÿ™ ŸÅŸÇÿ∑ÿå ŸÉŸÑ ÿÆŸäÿßÿ± ŸÅŸä ÿ≥ÿ∑ÿ±.")
        temp["options"] = options
        user_states[uid] = {"state": "awaiting_inference_correct", "temp": temp}
        bot.send_message(uid, "‚úÖ ŸÖÿß ŸáŸà ÿ±ŸÇŸÖ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©ÿü (ŸÖŸÜ 0 ÿ•ŸÑŸâ 3)")

    elif state["state"] == "awaiting_inference_correct":
        try:
            correct = int(msg.text.strip())
            if correct not in [0, 1, 2, 3]:
                raise ValueError()
        except:
            return bot.send_message(uid, "‚ö†Ô∏è ÿ£ÿ±ÿ≥ŸÑ ÿ±ŸÇŸÖŸãÿß ÿµÿ≠Ÿäÿ≠Ÿãÿß ŸÖŸÜ 0 ÿ•ŸÑŸâ 3 ŸÅŸÇÿ∑.")
        
        # ÿ≠ŸÅÿ∏ ŸÅŸä ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
        q = temp["question"]
        options = temp["options"]
        options_str = json.dumps(options)
        cursor.execute("""
        INSERT INTO inference_questions (question, options, correct_index, submitted_by)
        VALUES (?, ?, ?, ?)
        """, (q, options_str, correct, uid))
        conn.commit()

        user_states.pop(uid, None)
        bot.send_message(uid, "üéâ ÿ™ŸÖ ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿßŸÇÿ™ÿ±ÿßÿ≠ŸÉ ÿ®ŸÜÿ¨ÿßÿ≠! ÿ≥Ÿäÿ™ŸÖ ŸÖÿ±ÿßÿ¨ÿπÿ™Ÿá ŸÇÿ±Ÿäÿ®Ÿãÿß. ÿ¥ŸÉÿ±ÿßŸã ŸÑŸÖÿ≥ÿßŸáŸÖÿ™ŸÉ üôè")
# -------------------------------------------------------------------
#                           Run Bot
# -------------------------------------------------------------------

# Ÿàÿßÿ¨Ÿáÿ© Flask ŸÑŸÑŸÅÿ≠ÿµ
app = Flask(__name__)

@app.route('/')
def home():
    return "‚úÖ ÿßŸÑÿ®Ÿàÿ™ ŸäÿπŸÖŸÑ ÿßŸÑÿ¢ŸÜ"
@app.route('/anki_preview')
def anki_preview():
    user_cards = generate_anki_cards_from_text(text)[:5]  # ‚Üê ŸÜÿ≠ÿµŸÑ ÿπŸÑŸâ ÿ£ŸàŸÑ 5 ÿ®ÿ∑ÿßŸÇÿßÿ™
    session['cards'] = user_cards
    session['index'] = 0
    session['show_back'] = False
    return redirect('/anki')
    
app.secret_key = 'anki_secret'  # ÿ≥ÿ± ÿßŸÑÿ¨ŸÑÿ≥ÿ© ŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÖÿ§ŸÇÿ™Ÿãÿß


@app.route('/anki', methods=['GET', 'POST'])
def anki_cards():
    content = session.get('anki_content')
    major = session.get('anki_major', 'General')
    if 'cards' not in session:
        session['cards'] = example_cards[:5]
        session['index'] = 0
        session['show_back'] = False

    if request.method == 'POST':
        action = request.form.get('action')
        if action == 'show':
            session['show_back'] = True
        elif action == 'next':
            session['index'] += 1
            session['show_back'] = False

    index = session['index']
    cards = session['cards']

    if index >= len(cards):
        session.clear()
        return "<h2>üéâ ÿßŸÜÿ™ŸáŸäÿ™ ŸÖŸÜ ÿßŸÑÿ®ÿ∑ÿßŸÇÿßÿ™! ÿ£ÿ≠ÿ≥ŸÜÿ™.</h2><a href='/anki'>üîÅ ÿßÿ®ÿØÿ£ ŸÖŸÜ ÿ¨ÿØŸäÿØ</a>"

    return render_template('anki_viewer.html',
                           card=cards[index],
                           index=index,
                           total=len(cards),
                           show_back=session['show_back'])
# ÿ®ÿØÿ° ÿßŸÑÿ®Ÿàÿ™

# ÿ™ÿ¥ÿ∫ŸäŸÑ ÿ®Ÿàÿ™ ÿ™ŸäŸÑŸäÿ∫ÿ±ÿßŸÖ ŸÅŸä Thread ŸÖŸÜŸÅÿµŸÑ
def run_bot():
    print("ü§ñ Bot polling started...")
    bot.infinity_polling()

threading.Thread(target=run_bot).start()

# ÿ™ÿ¥ÿ∫ŸäŸÑ ÿÆÿßÿØŸÖ Flask ÿπŸÑŸâ ÿßŸÑŸÖŸÜŸÅÿ∞ ÿßŸÑÿ∞Ÿä ÿ™ÿ≠ÿØÿØŸá Render
if __name__ == "__main__":
    port = int(os.environ.get("PORT", 5000))  # Render ŸäŸàŸÅÿ± PORT ŸÉŸÖÿ™ÿ∫Ÿäÿ± ÿ®Ÿäÿ¶ÿ©
    app.run(host="0.0.0.0", port=port)
