import os
import sqlite3
import time # <--- ÿ£ÿ∂ŸÅ Ÿáÿ∞ÿß ÿßŸÑÿ≥ÿ∑ÿ±
from datetime import datetime, timedelta
from flask import Flask
import telebot
from telebot.types import ChatPermissions
import threading
import logging
from dotenv import load_dotenv
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton
import docx
import fitz                     # PyMuPDF
import google.generativeai as genai
import requests
import cohere
from groq import Groq
import json
import re



# ŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿßŸÑÿ®Ÿäÿ¶ÿ©
load_dotenv()
BOT_TOKEN = os.getenv("BOT_TOKEN")
GROUP_ID = int(os.getenv("GROUP_ID"))
ADMIN_ID = int(os.getenv("ADMIN_ID"))
GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')
OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")
COHERE_API_KEY = os.getenv("COHERE_API_KEY")
GROQ_API_KEY = os.getenv("GROQ_API_KEY")

bot = telebot.TeleBot(BOT_TOKEN)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-


# --- ÿ•ÿπÿØÿßÿØ ÿßŸÑŸÖŸÅÿßÿ™Ÿäÿ≠ ŸàÿßŸÑÿπŸÖŸÑ

# 1. ÿ•ÿπÿØÿßÿØ Google Gemini
gemini_model = None
if GEMINI_API_KEY:
    try:
        genai.configure(api_key=GEMINI_API_KEY)
        gemini_model = genai.GenerativeModel('gemini-1.5-flash')
        logging.info("‚úÖ 1. Gemini configured successfully")
    except Exception as e:
        logging.warning(f"‚ö†Ô∏è Could not configure Gemini: {e}")

# 2. ÿ•ÿπÿØÿßÿØ Groq
groq_client = None
if GROQ_API_KEY:
    try:
        groq_client = Groq(api_key=GROQ_API_KEY)
        logging.info("‚úÖ 2. Groq configured successfully")
    except Exception as e:
        logging.warning(f"‚ö†Ô∏è Could not configure Groq: {e}")

# 3. ÿ•ÿπÿØÿßÿØ OpenRouter (ÿ≥Ÿäÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖŸá ŸÑŸÜŸÖŸàÿ∞ÿ¨ŸäŸÜ ŸÖÿÆÿ™ŸÑŸÅŸäŸÜ)
if OPENROUTER_API_KEY:
    logging.info("‚úÖ 3. OpenRouter is ready")

# 4. ÿ•ÿπÿØÿßÿØ Cohere
cohere_client = None
if COHERE_API_KEY:
    try:
        cohere_client = cohere.Client(COHERE_API_KEY)
        logging.info("‚úÖ 4. Cohere configured successfully")
    except Exception as e:
        logging.warning(f"‚ö†Ô∏è Could not configure Cohere: {e}")


# --- ÿßŸÑÿØÿßŸÑÿ© ÿßŸÑŸÖŸàÿ≠ÿØÿ© ŸÑÿ™ŸàŸÑŸäÿØ ÿßŸÑÿ±ÿØŸàÿØ ---

def generate_gemini_response(prompt: str) -> str:
    """
    Tries to generate a response by attempting a chain of services silently.
    It logs errors for the developer but does not send progress messages to the user.
    """
    timeout_seconds = 45

    # 1Ô∏è‚É£ OpenRouter - Nous Hermes 2 (ÿ£ŸÅÿ∂ŸÑ ÿØÿπŸÖ ŸÑŸÑÿπÿ±ÿ®Ÿäÿ©)
    if OPENROUTER_API_KEY:
        try:
            logging.info("Attempting request with: 1. OpenRouter (Nous Hermes 2)...")
            headers = {
            "Authorization": f"Bearer {OPENROUTER_API_KEY}",
            "HTTP-Referer": "https://t.me/Oiuhelper_bot",  # ‚Üê ÿ∫ŸäŸëÿ± Ÿáÿ∞ÿß ÿ•ŸÑŸâ ÿ±ÿßÿ®ÿ∑ ÿßŸÑÿ®Ÿàÿ™
            "X-Title": "AI Quiz Bot"
            }
            model_identifier = "nousresearch/nous-hermes-2-mistral:free"
            response = requests.post(
            url="https://openrouter.ai/api/v1/chat/completions",
            headers=headers,
                json={
                "model": model_identifier,
                "messages": [{"role": "user", "content": prompt}]
            },
            timeout=timeout_seconds
            )
            response.raise_for_status()
            result_text = response.json()['choices'][0]['message']['content']
            logging.info("‚úÖ Success with OpenRouter (Nous Hermes 2).")
            return result_text
        except Exception as e:
            logging.warning(f"‚ùå OpenRouter (Nous Hermes 2) failed: {e}")

    # 2Ô∏è‚É£ Groq (LLaMA 3)
    if groq_client:
        try:
            logging.info("Attempting request with: 2. Groq (LLaMA 3)...")
            chat_completion = groq_client.chat.completions.create(
                messages=[{"role": "user", "content": prompt}],
                model="llama3-8b-8192",
                temperature=0.7,
                timeout=timeout_seconds
            )
            if chat_completion.choices[0].message.content:
                logging.info("‚úÖ Success with Groq.")
                return chat_completion.choices[0].message.content
            else:
                logging.warning("‚ùå Groq returned no text. Trying fallback...")
        except Exception as e:
            logging.warning(f"‚ùå Groq failed: {e}")

    # 3Ô∏è‚É£ OpenRouter - Gemma
    if OPENROUTER_API_KEY:
        try:
            logging.info("Attempting request with: 3. OpenRouter (Gemma)...")
            headers = {
                "Authorization": f"Bearer {OPENROUTER_API_KEY}",
                "HTTP-Referer": "https://t.me/Oiuhelper_bot",  # Replace with your bot's link
                "X-Title": "AI Quiz Bot"
            }
            model_identifier = "google/gemma-7b-it:free"
            response = requests.post(
                url="https://openrouter.ai/api/v1/chat/completions",
                headers=headers,
                json={"model": model_identifier, "messages": [{"role": "user", "content": prompt}]},
                timeout=timeout_seconds
            )
            response.raise_for_status()
            result_text = response.json()['choices'][0]['message']['content']
            logging.info("‚úÖ Success with OpenRouter (Gemma).")
            return result_text
        except Exception as e:
            logging.warning(f"‚ùå OpenRouter (Gemma) failed: {e}")

    # 4Ô∏è‚É£ Google Gemini
    if gemini_model:
        try:
            logging.info("Attempting request with: 4. Google Gemini...")
            request_options = {"timeout": timeout_seconds}
            response = gemini_model.generate_content(prompt, request_options=request_options)
            if response.text:
                logging.info("‚úÖ Success with Gemini.")
                return response.text
            else:
                logging.warning("‚ùå Gemini returned no text. Trying fallback...")
        except Exception as e:
            logging.warning(f"‚ùå Gemini failed: {e}")

    # 5Ô∏è‚É£ Cohere
    if cohere_client:
        try:
            logging.info("Attempting request with: 5. Cohere...")
            response = cohere_client.chat(model='command-r', message=prompt)
            logging.info("‚úÖ Success with Cohere.")
            return response.text
        except Exception as e:
            logging.warning(f"‚ùå Cohere failed: {e}")

    # üö´ All models failed
    logging.error("‚ùå All API providers failed. Returning empty string.")
    return ""


def generate_smart_response(prompt: str) -> str:
    """
    Tries to generate a response by attempting a chain of services silently.
    It logs errors for the developer but does not send progress messages to the user.
    """
    timeout_seconds = 45


    #  1Ô∏è‚É£ Cohere
    if cohere_client:
        try:
            logging.info("Attempting request with: 5. Cohere...")
            response = cohere_client.chat(model='command-r', message=prompt)
            logging.info("‚úÖ Success with Cohere.")
            return response.text
        except Exception as e:
            logging.warning(f"‚ùå Cohere failed: {e}")



    # 2Ô∏è‚É£ Google Gemini
    if gemini_model:
        try:
            logging.info("Attempting request with: 4. Google Gemini...")
            request_options = {"timeout": timeout_seconds}
            response = gemini_model.generate_content(prompt, request_options=request_options)
            if response.text:
                logging.info("‚úÖ Success with Gemini.")
                return response.text
            else:
                logging.warning("‚ùå Gemini returned no text. Trying fallback...")
        except Exception as e:
            logging.warning(f"‚ùå Gemini failed: {e}")


    #  3Ô∏è‚É£  Groq (LLaMA 3)
    if groq_client:
        try:
            logging.info("Attempting request with: 2. Groq (LLaMA 3)...")
            chat_completion = groq_client.chat.completions.create(
                messages=[{"role": "user", "content": prompt}],
                model="llama3-8b-8192",
                temperature=0.7,
                timeout=timeout_seconds
            )
            if chat_completion.choices[0].message.content:
                logging.info("‚úÖ Success with Groq.")
                return chat_completion.choices[0].message.content
            else:
                logging.warning("‚ùå Groq returned no text. Trying fallback...")
        except Exception as e:
            logging.warning(f"‚ùå Groq failed: {e}")

    # 4Ô∏è‚É£# 5Ô∏è‚É£ OpenRouter - Gemma
    if OPENROUTER_API_KEY:
        try:
            logging.info("Attempting request with: 3. OpenRouter (Gemma)...")
            headers = {
                "Authorization": f"Bearer {OPENROUTER_API_KEY}",
                "HTTP-Referer": "https://t.me/Oiuhelper_bot",  # Replace with your bot's link
                "X-Title": "AI Quiz Bot"
            }
            model_identifier = "google/gemma-7b-it:free"
            response = requests.post(
                url="https://openrouter.ai/api/v1/chat/completions",
                headers=headers,
                json={"model": model_identifier, "messages": [{"role": "user", "content": prompt}]},
                timeout=timeout_seconds
            )
            response.raise_for_status()
            result_text = response.json()['choices'][0]['message']['content']
            logging.info("‚úÖ Success with OpenRouter (Gemma).")
            return result_text
        except Exception as e:
            logging.warning(f"‚ùå OpenRouter (Gemma) failed: {e}")

    # üö´ All models failed
    logging.error("‚ùå All API providers failed. Returning empty string.")
    return ""
# -------------------------------------------------------------------
#                  Logging & Database Setup
# -------------------------------------------------------------------
logging.basicConfig(level=logging.INFO,
                    format="%(asctime)s [%(levelname)s] %(message)s")

conn   = sqlite3.connect("quiz_users.db", check_same_thread=False)
cursor = conn.cursor()

# ÿ¨ÿØŸàŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ
cursor.execute("""
CREATE TABLE IF NOT EXISTS users (
    user_id     INTEGER PRIMARY KEY,
    major       TEXT,
    native_lang TEXT DEFAULT 'ar',
    quiz_count  INTEGER DEFAULT 0,
    last_reset  TEXT
)
""")

# ÿ¨ÿØŸàŸÑ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑŸÖŸÇÿ™ÿ±ÿ≠ÿ© ŸÖŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ŸÑŸÑÿπÿ®ÿ© ÿßŸÑÿßÿ≥ÿ™ŸÜÿ™ÿßÿ¨
cursor.execute("""
CREATE TABLE IF NOT EXISTS inference_questions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    question TEXT NOT NULL,
    options TEXT NOT NULL,         -- ÿ≥Ÿäÿ™ŸÖ ÿ™ÿÆÿ≤ŸäŸÜŸáÿß ŸÉÿ≥ŸÑÿ≥ŸÑÿ© JSON
    correct_index INTEGER NOT NULL,
    submitted_by INTEGER,
    approved INTEGER DEFAULT 0
)
""")
cursor.execute("""
CREATE TABLE IF NOT EXISTS game_attempts (
    user_id INTEGER,
    game_type TEXT,
    date TEXT,
    PRIMARY KEY (user_id, game_type)
)
""")
conn.commit()


# track temporary state for custom-major input
user_states = {}

# -------------------------------------------------------------------
#                     Text Extraction & OCR
# -------------------------------------------------------------------
def extract_text_from_pdf(path: str) -> str:
    try:
        doc = fitz.open(path)
        text = "\n".join([page.get_text() for page in doc])
        return text.strip()
    except Exception as e:
        logging.error(f"Error extracting PDF text: {e}")
        return ""
    # fallback to PyMuPDF text extraction
    doc = fitz.open(path)
    return "\n".join([page.get_text() for page in doc])
# ÿ£ÿ∂ŸÅ Ÿáÿ∞Ÿá ÿßŸÑÿØÿßŸÑÿ© ŸÅŸä ŸÇÿ≥ŸÖ Text Extraction & OCR
def extract_text_from_docx(path: str) -> str:
    try:
        doc = docx.Document(path)
        full_text = []
        for para in doc.paragraphs:
            full_text.append(para.text)
        return '\n'.join(full_text)
    except Exception as e:
        logging.error(f"Error extracting DOCX text: {e}")
        return ""

# ŸàŸäÿ¨ÿ® ÿ£Ÿäÿ∂ÿßŸã ÿ™ÿπÿ±ŸäŸÅ ÿØÿßŸÑÿ© ŸÑŸÖŸÑŸÅÿßÿ™ txt
def extract_text_from_txt(path: str) -> str:
    try:
        with open(path, 'r', encoding='utf-8') as f:
            return f.read()
    except Exception as e:
        logging.error(f"Error extracting TXT text: {e}")
        return ""

# -------------------------------------------------------------------
#                     Quota Management
# -------------------------------------------------------------------
def reset_if_needed(user_id: int):
    this_month = datetime.now().strftime("%Y-%m")
    cursor.execute("SELECT last_reset FROM users WHERE user_id = ?", (user_id,))
    row = cursor.fetchone()
    if not row or row[0] != this_month:
        cursor.execute("""
            INSERT OR REPLACE INTO users(user_id, major, quiz_count, last_reset)
            VALUES (?, COALESCE((SELECT major FROM users WHERE user_id=?), ''), 0, ?)
        """, (user_id, user_id, this_month))
        conn.commit()

def can_generate(user_id: int) -> bool:
    # --- ÿ®ÿØÿßŸäÿ© ÿßŸÑÿ™ÿπÿØŸäŸÑ ---
    # ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸáŸà ÿßŸÑÿ£ÿØŸÖŸÜÿå ÿßÿ≥ŸÖÿ≠ ŸÑŸá ÿØÿßÿ¶ŸÖŸãÿß ÿ®ÿßŸÑÿ™ŸàŸÑŸäÿØ
    if user_id == ADMIN_ID:
        return True
    # --- ŸÜŸáÿßŸäÿ© ÿßŸÑÿ™ÿπÿØŸäŸÑ ---

    reset_if_needed(user_id)
    cursor.execute("SELECT quiz_count FROM users WHERE user_id = ?", (user_id,))
    row = cursor.fetchone()
    # ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÖŸàÿ¨ŸàÿØ ŸÇÿ®ŸÑ ŸÖÿ≠ÿßŸàŸÑÿ© ÿßŸÑŸàÿµŸàŸÑ ÿ•ŸÑŸâ ÿßŸÑÿπÿØ
    if not row:
        return True # ŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ¨ÿØŸäÿØÿå ŸäŸÖŸÉŸÜŸá ÿßŸÑÿ™ŸàŸÑŸäÿØ
    count = row[0]
    return count < 3

def increment_count(user_id: int):
    # --- ÿ®ÿØÿßŸäÿ© ÿßŸÑÿ™ÿπÿØŸäŸÑ ---
    # ŸÑÿß ÿ™ŸÇŸÖ ÿ®ÿ≤ŸäÿßÿØÿ© ÿßŸÑÿπÿØÿßÿØ ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸáŸà ÿßŸÑÿ£ÿØŸÖŸÜ
    if user_id == ADMIN_ID:
        bot.send_message(ADMIN_ID, "‚ú® (Ÿàÿ∂ÿπ ÿßŸÑÿ£ÿØŸÖŸÜ: ŸÑŸÖ Ÿäÿ™ŸÖ ÿßÿ≠ÿ™ÿ≥ÿßÿ® Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ©)")
        return
    # --- ŸÜŸáÿßŸäÿ© ÿßŸÑÿ™ÿπÿØŸäŸÑ ---
    
    cursor.execute("UPDATE users SET quiz_count = quiz_count + 1 WHERE user_id = ?", (user_id,))
    conn.commit()

from datetime import date

def can_play_game_today(user_id: int, game_type: str) -> bool:
    today = str(date.today())
    cursor.execute(
        "SELECT 1 FROM game_attempts WHERE user_id = ? AND game_type = ? AND date = ?",
        (user_id, game_type, today)
    )
    return cursor.fetchone() is None

def record_game_attempt(user_id: int, game_type: str):
    today = str(date.today())
    cursor.execute(
        "INSERT OR REPLACE INTO game_attempts(user_id, game_type, date) VALUES (?, ?, ?)",
        (user_id, game_type, today)
    )
    conn.commit()

# -------------------------------------------------------------------
#                 Quiz Generation & Formatting
# -------------------------------------------------------------------

def extract_json_from_string(text: str) -> str:
    """
    Extracts a JSON string from a text that might contain markdown code blocks or other text.
    """
    # ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿ®ŸÑŸàŸÉ JSON ÿØÿßÿÆŸÑ ```json ... ```
    match = re.search(r'```json\s*([\s\S]*?)\s*```', text)
    if match:
        return match.group(1).strip()

    # ÿ•ÿ∞ÿß ŸÑŸÖ Ÿäÿ¨ÿØ ÿ®ŸÑŸàŸÉÿå ÿßÿ®ÿ≠ÿ´ ÿπŸÜ ÿ£ŸàŸÑ '{' ÿ£Ÿà '[' Ÿàÿ¢ÿÆÿ± '}' ÿ£Ÿà ']'
    start = -1
    end = -1
    
    # ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿ®ÿØÿßŸäÿ© ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿ£Ÿà ÿßŸÑŸÉÿßÿ¶ŸÜ
    first_brace = text.find('{')
    first_bracket = text.find('[')
    
    if first_brace == -1:
        start = first_bracket
    elif first_bracket == -1:
        start = first_brace
    else:
        start = min(first_brace, first_bracket)

    # ÿ•ÿ∞ÿß ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ®ÿØÿßŸäÿ©ÿå ÿ£ÿ±ÿ¨ÿπ ÿßŸÑŸÜÿµ ÿßŸÑÿ£ÿµŸÑŸä
    if start == -1:
        return text

    # ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ŸÜŸáÿßŸäÿ© ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿ£Ÿà ÿßŸÑŸÉÿßÿ¶ŸÜ
    last_brace = text.rfind('}')
    last_bracket = text.rfind(']')
    end = max(last_brace, last_bracket)

    # ÿ•ÿ∞ÿß ÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ®ÿØÿßŸäÿ© ŸàŸÜŸáÿßŸäÿ©ÿå ÿ£ÿ±ÿ¨ÿπ ŸÖÿß ÿ®ŸäŸÜŸáŸÖÿß
    if end > start:
        return text[start:end+1].strip()
        
    # ŸÉÿÆŸäÿßÿ± ÿ£ÿÆŸäÿ±ÿå ÿ£ÿ±ÿ¨ÿπ ÿßŸÑŸÜÿµ ŸÉŸÖÿß ŸáŸà
    return text
    
def generate_quizzes_from_text(text: str, major: str, user_id: int, num_quizzes: int = 10):  # <-- ÿ£ÿ∂ŸÅ user_id
    prompt = (
    f"You are a strict AI quiz generator. Your only task is to generate a JSON array of {num_quizzes} quiz questions "
    f"that are based **strictly and only** on the information explicitly stated in the following content.\n\n"
    "‚ùóÔ∏èImportant Rules:\n"
    "- DO NOT invent, infer, or assume any information not clearly mentioned in the text.\n"
    "- If a concept is not explained or mentioned clearly in the content, DO NOT create a question about it.\n"
    "- Stay fully inside the boundaries of the content.\n"
    "- Every question must test **recall** or **recognition** from the provided text only, not general knowledge.\n\n"
    "Each question must be an object with:\n"
    "- 'question': the question string\n"
    "- 'options': a list of exactly 4 answer options\n"
    "- 'correct_index': the index (0-3) of the correct answer in the options list\n\n"
    "‚ö†Ô∏è Format Instructions:\n"
    "- ONLY return a raw JSON array. No markdown, no explanation, no formatting.\n"
    "- Do not include any introductory or closing text.\n"
    "- Ensure the JSON is valid and parsable.\n\n"
    f"Content:\n{text}"
)

    # ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑÿØÿßŸÑÿ© ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿµŸÑÿßÿ≠Ÿäÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
    if user_id == ADMIN_ID or can_generate(user_id):  # <-- ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸáŸÜÿß
        raw_response = generate_smart_response(prompt)
    else:
        raw_response = generate_gemini_response(prompt)

    
    # --- ÿßŸÑÿ™ÿπÿØŸäŸÑ Ÿäÿ®ÿØÿ£ ŸáŸÜÿß ---
    # 1. ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© ŸÑÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿßŸÑŸÄ JSON
    clean_json_str = extract_json_from_string(raw_response)
    
    # 2. ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÖÿß ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© ŸÅÿßÿ±ÿ∫ÿ© ÿ®ÿπÿØ ÿßŸÑÿ™ŸÜÿ∏ŸäŸÅ
    if not clean_json_str:
        logging.error(f"‚ùå JSON extraction failed. Raw output was:\n{raw_response}")
        return [] # ÿ£ÿ±ÿ¨ÿπ ŸÇÿßÿ¶ŸÖÿ© ŸÅÿßÿ±ÿ∫ÿ© ÿ®ÿØŸÑÿßŸã ŸÖŸÜ ÿ±ÿ≥ÿßŸÑÿ© ÿÆÿ∑ÿ£

    try:
        # 3. ŸÖÿ≠ÿßŸàŸÑÿ© ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ≥ŸÑÿ≥ŸÑÿ© ÿßŸÑŸÜÿ∏ŸäŸÅÿ©
        quizzes_json = json.loads(clean_json_str)
        quizzes = []

        for item in quizzes_json:
            q = item.get("question", "").strip()
            opts = item.get("options", [])
            corr = item.get("correct_index", -1)

            if isinstance(q, str) and q and isinstance(opts, list) and len(opts) == 4 and isinstance(corr, int) and 0 <= corr < 4:
                quizzes.append((q, [str(opt).strip() for opt in opts], corr))
            else:
                logging.warning(f"‚ùå Skipping invalid question structure: {item}")

        return quizzes

    except json.JSONDecodeError as e:
        logging.error(f"‚ùå JSON parsing failed: {e}\nCleaned string was:\n{clean_json_str}\nRaw output was:\n{raw_response}")
        return [] # ÿ£ÿ±ÿ¨ÿπ ŸÇÿßÿ¶ŸÖÿ© ŸÅÿßÿ±ÿ∫ÿ© ÿπŸÜÿØ ÿßŸÑŸÅÿ¥ŸÑ
    # --- ÿßŸÑÿ™ÿπÿØŸäŸÑ ŸäŸÜÿ™ŸáŸä ŸáŸÜÿß ---



# -------------------------------------------------------------------
#                 games
# -------------------------------------------------------------------

def generate_vocabulary_game(user_id, major, native_lang="Arabic"):  
    prompt = f"""  
You are an AI vocabulary quiz creator.  
  
Generate one vocabulary question for a student majoring in {major}.  
- Show the meaning of an English word in {native_lang}  
- Provide 4 English words as options  
- Only ONE option should be correct.  
- Don't explain anything. Just give raw JSON.  
  
Example:  
{{  
  "question": "ŸÖÿπŸÜŸâ: Ÿäÿ¥ÿ±ÿ≠ ÿ®ÿ™ŸÅÿµŸäŸÑ",  
  "options": ["explain", "explode", "expose", "explore"],  
  "correct_index": 0  
}}  
"""  
    game_response = generate_smart_response(prompt)  
    clean_json_str = extract_json_from_string(game_response)  
    return json.loads(clean_json_str)  # ‚úÖ Ÿäÿ±ÿ¨ÿπ dict ŸäŸÖŸÉŸÜ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖŸá ŸÖÿ®ÿßÿ¥ÿ±ÿ©

def generate_speed_challenge(user_id, major):
    prompt = f"""
Create a fast-answer quiz for a student in {major}.

- Make the question short and time-sensitive.
- Options should be short words or phrases.
- Use random fun/general knowledge topics (not too academic).
- Response format is raw JSON:

{{
  "question": "What is the capital of France?",
  "options": ["Paris", "Berlin", "London", "Rome"],
  "correct_index": 0
}}
"""
    game_response = generate_smart_response(prompt)  
    clean_json_str = extract_json_from_string(game_response)  
    return json.loads(clean_json_str)  # ‚úÖ Ÿäÿ±ÿ¨ÿπ dict ŸäŸÖŸÉŸÜ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖŸá ŸÖÿ®ÿßÿ¥ÿ±ÿ©



# ‚òÖ ŸÑÿπÿ®ÿ© ÿßŸÑÿßÿÆÿ∑ÿßÿ° ÿßŸÑÿ¥ÿßÿ¶ÿπÿ©

def generate_common_mistakes_game(user_id, major):
    prompt = f"""
Generate one multiple-choice question based on a common mistake made by students in the {major} field.

- The question must highlight a misconception or error.
- Provide 4 choices with 1 correct.
- Don't explain.
- Respond with raw JSON:

{{
  "question": "Which of the following is a common mistake in anatomy?",
  "options": ["Heart has 3 chambers", "Liver detoxifies blood", "Skin is the largest organ", "Neurons transmit signals"],
  "correct_index": 0
}}
"""
    game_response = generate_smart_response(prompt)  
    clean_json_str = extract_json_from_string(game_response)  
    return json.loads(clean_json_str)  # ‚úÖ Ÿäÿ±ÿ¨ÿπ dict ŸäŸÖŸÉŸÜ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖŸá ŸÖÿ®ÿßÿ¥ÿ±ÿ©


def generate_inference_game(user_id):
    prompt = """
You are an AI life skills quiz creator.

Create a thought-provoking question that develops one of the following skills:
- Critical thinking
- Emotional intelligence
- Time management
- Self-awareness
- Decision making
- Problem-solving
- Logic
- Pattern recognition
- Mental map understanding

Use real-world scenarios or academic life examples.

Return as raw JSON:
{
  "question": "Ahmed has 3 tasks: writing a paper, replying to urgent emails, and preparing for tomorrow‚Äôs exam. Which should he do first?",
  "options": ["Write the paper", "Reply to emails", "Prepare for exam", "Take a break"],
  "correct_index": 2
}
"""
    game_response = generate_smart_response(prompt)  
    clean_json_str = extract_json_from_string(game_response)  
    return json.loads(clean_json_str)  # ‚úÖ Ÿäÿ±ÿ¨ÿπ dict ŸäŸÖŸÉŸÜ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖŸá ŸÖÿ®ÿßÿ¥ÿ±ÿ©


# ----------------------------------
# ------------- inference review -------------------------------------------------------------------


def review_inference_question_with_ai(question_text: str, options: list[str], correct_index: int) -> bool:
    prompt = f"""
You are an AI educational assistant.

A student submitted the following inference question. Review it and decide if it's valid:
- Is the question clear and meaningful?
- Are the 4 options distinct and related to the question?
- Is there **one and only one correct answer**?

Respond only with YES or NO.

Question: {question_text}
Options: {options}
Correct index: {correct_index}
"""
    response = generate_smart_response(prompt).strip().lower()
    return "yes" in response


def process_pending_inference_questions():
    cursor.execute("SELECT id, question, options, correct_index FROM inference_questions WHERE approved = 0")
    pending = cursor.fetchall()

    for row in pending:
        qid, qtext, options_json, correct_index = row
        try:
            options = json.loads(options_json)
        except:
            continue  # ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿ∞ÿßÿ™ ÿßŸÑÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑÿÆÿßÿ∑ÿ¶

        if review_inference_question_with_ai(qtext, options, correct_index):
            cursor.execute("UPDATE inference_questions SET approved = 1 WHERE id = ?", (qid,))
        else:
            cursor.execute("DELETE FROM inference_questions WHERE id = ?", (qid,))

    conn.commit()





def send_quizzes_as_polls(chat_id: int, quizzes: list):
    """
    Sends a list of quizzes to a user as separate Telegram polls.
    
    :param chat_id: The user's chat ID.
    :param quizzes: A list of quiz tuples, where each tuple is
                    (question, options_list, correct_index).
    """
    # ŸÜÿ±ÿ≥ŸÑ ÿ±ÿ≥ÿßŸÑÿ© ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÜÿÆÿ®ÿ±Ÿá ŸÅŸäŸáÿß ÿ®ÿπÿØÿØ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ©
    bot.send_message(chat_id, f"ÿ™ŸÖ ÿ™ÿ¨ŸáŸäÿ≤ {len(quizzes)} ÿ≥ÿ§ÿßŸÑŸãÿß. ÿßÿ≥ÿ™ÿπÿØ ŸÑŸÑÿßÿÆÿ™ÿ®ÿßÿ±!")
    time.sleep(2) # ŸÜŸÜÿ™ÿ∏ÿ± ÿ´ÿßŸÜŸäÿ™ŸäŸÜ ŸÇÿ®ŸÑ ÿ®ÿØÿ° ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±

    for i, quiz_data in enumerate(quizzes):
        try:
            question, options, correct_index = quiz_data
            
            # ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ ÿ∑ŸàŸÑ ÿßŸÑÿ≥ÿ§ÿßŸÑ ŸàÿßŸÑÿÆŸäÿßÿ±ÿßÿ™ ÿ∂ŸÖŸÜ ÿ≠ÿØŸàÿØ ÿ™ŸÑŸäÿ¨ÿ±ÿßŸÖ
            question_text = f"‚ùì ÿßŸÑÿ≥ÿ§ÿßŸÑ {i+1}:\n\n{question}"
            if len(question_text) > 300: # ÿ≠ÿØ ÿ™ŸÑŸäÿ¨ÿ±ÿßŸÖ ŸÑÿ∑ŸàŸÑ ÿßŸÑÿ≥ÿ§ÿßŸÑ ŸáŸà 300 ÿ≠ÿ±ŸÅ
                question_text = question_text[:297] + "..."

            bot.send_poll(
                chat_id=chat_id,
                question=question_text,
                options=options,
                type='quiz',
                correct_option_id=correct_index,
                is_anonymous=False, # ŸÅŸä ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™ÿå ÿπÿßÿØÿ© ŸÖÿß ÿ™ŸÉŸàŸÜ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿßÿ™ ÿ∫Ÿäÿ± ŸÖÿ¨ŸáŸàŸÑÿ©
                explanation=f"ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ© ŸáŸä: {options[correct_index]}"
            )
            
            # ŸÜŸÜÿ™ÿ∏ÿ± ÿ´ÿßŸÜŸäÿ© Ÿàÿßÿ≠ÿØÿ© ÿ®ŸäŸÜ ŸÉŸÑ ÿ≥ÿ§ÿßŸÑ ŸÑÿ™ÿ¨ŸÜÿ® ŸÖÿ¥ÿßŸÉŸÑ ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ≥ÿ±Ÿäÿπ
            time.sleep(1)

        except Exception as e:
            logging.error(f"Could not send poll for quiz: {quiz_data}. Error: {e}")
            bot.send_message(chat_id, f"ÿπÿ∞ÿ±Ÿãÿßÿå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿ±ŸÇŸÖ {i+1}. ÿ≥ŸÜÿ™ÿ¨ÿßŸàÿ≤Ÿá ŸàŸÜŸÉŸÖŸÑ.")
            continue # ŸÜŸÜÿ™ŸÇŸÑ ŸÑŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ™ÿßŸÑŸä ŸÅŸä ÿ≠ÿßŸÑÿ© ÿ≠ÿØŸàÿ´ ÿÆÿ∑ÿ£

    bot.send_message(chat_id, "üéâ ÿßŸÜÿ™ŸáŸâ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±! ÿ®ÿßŸÑÿ™ŸàŸÅŸäŸÇ.")


# -------------------------------------------------------------------
#                  Telegram Bot Handlers
# -------------------------------------------------------------------

@bot.message_handler(commands=['start'])
def cmd_start(msg):
    keyboard = InlineKeyboardMarkup(row_width=2)
    buttons = [
        InlineKeyboardButton("üìù ÿ™ŸàŸÑŸäÿØ ÿßÿÆÿ™ÿ®ÿßÿ±", callback_data="go_generate"),
        InlineKeyboardButton("üìö ŸÖÿ±ÿßÿ¨ÿπÿ© ÿ≥ÿ±Ÿäÿπÿ©", callback_data="soon_review"),
        InlineKeyboardButton("üìÑ ŸÖŸÑÿÆÿµ PDF", callback_data="soon_summary"),
        InlineKeyboardButton("üß† ÿ®ÿ∑ÿßŸÇÿßÿ™ Anki", callback_data="soon_anki"),
        InlineKeyboardButton("üéÆ ÿ£ŸÑÿπÿßÿ® ÿ™ÿπŸÑŸäŸÖŸäÿ©", callback_data="go_games"),
        InlineKeyboardButton("‚öôÔ∏è ÿ≠ÿ≥ÿßÿ®Ÿä", callback_data="soon_account"),
    ]
    keyboard.add(*buttons)

    bot.send_message(
        msg.chat.id,
        "üëã ÿ£ŸáŸÑÿßŸã ÿ®ŸÉ ŸÅŸä TestGenie ‚ú®\n\n"
        "üéØ ÿ£ÿØŸàÿßÿ™ ÿ™ÿπŸÑŸäŸÖŸäÿ© ÿ∞ŸÉŸäÿ©:\n"
        "- ÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™ ŸÖŸÜ ŸÖŸÑŸÅÿßÿ™ŸÉ\n"
        "- ÿ®ÿ∑ÿßŸÇÿßÿ™ ŸÖÿ±ÿßÿ¨ÿπÿ© (Anki)\n"
        "- ŸÖŸÑÿÆÿµÿßÿ™ PDF/Word\n"
        "- ÿ£ŸÑÿπÿßÿ® ÿ™ÿπŸÑŸäŸÖŸäÿ© *(ŸÇÿ±Ÿäÿ®Ÿãÿß)*\n\n"
        "üìå ŸÑÿØŸäŸÉ 3 ÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™ ŸÖÿ¨ÿßŸÜŸäÿ© ÿ¥Ÿáÿ±ŸäŸãÿß.\n\n"
        "ÿßÿÆÿ™ÿ± ŸÖÿß ŸäŸÜÿßÿ≥ÿ®ŸÉ üëá",
        reply_markup=keyboard
    )

@bot.callback_query_handler(func=lambda c: c.data.startswith("go_") or c.data.startswith("soon_"))
def handle_main_menu(c):
    uid = c.from_user.id

    if c.data == "go_generate":
        keyboard = InlineKeyboardMarkup()
        buttons = [
            ("ü©∫ ÿßŸÑÿ∑ÿ®", "major_ÿßŸÑÿ∑ÿ®"),
            ("üõ†Ô∏è ÿßŸÑŸáŸÜÿØÿ≥ÿ©", "major_ÿßŸÑŸáŸÜÿØÿ≥ÿ©"),
            ("üíä ÿßŸÑÿµŸäÿØŸÑÿ©", "major_ÿßŸÑÿµŸäÿØŸÑÿ©"),
            ("üó£Ô∏è ÿßŸÑŸÑÿ∫ÿßÿ™", "major_ÿßŸÑŸÑÿ∫ÿßÿ™"),
            ("‚ùì ÿ∫Ÿäÿ± ÿ∞ŸÑŸÉ...", "major_custom"),
        ]
        for text, data in buttons:
            keyboard.add(InlineKeyboardButton(text, callback_data=data))
        keyboard.add(InlineKeyboardButton("‚¨ÖÔ∏è ÿ±ÿ¨Ÿàÿπ", callback_data="go_back_home"))

        bot.edit_message_text(
            "üéØ Ÿáÿ∞ÿß ÿßŸÑÿ®Ÿàÿ™ Ÿäÿ≥ÿßÿπÿØŸÉ ÿπŸÑŸâ ÿ™ŸàŸÑŸäÿØ ÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™ ÿ∞ŸÉŸäÿ© ŸÖŸÜ ŸÖŸÑŸÅÿßÿ™ŸÉ ÿßŸÑÿØÿ±ÿßÿ≥Ÿäÿ© ÿ£Ÿà ÿßŸÑŸÜÿµŸàÿµÿå ÿ≠ÿ≥ÿ® ÿ™ÿÆÿµÿµŸÉ.\n"
            "üìå ŸÖÿ™ÿßÿ≠ ŸÑŸÉ 3 ÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™ ŸÖÿ¨ÿßŸÜŸäÿ© ÿ¥Ÿáÿ±ŸäŸãÿß.\n"
            "ÿßÿÆÿ™ÿ± ÿ™ÿÆÿµÿµŸÉ ŸÑŸÑÿ®ÿØÿ° üëá",
            chat_id=c.message.chat.id,
            message_id=c.message.message_id,
            reply_markup=keyboard
        )

    elif c.data == "go_games":
        cursor.execute("SELECT major FROM users WHERE user_id = ?", (uid,))
        row = cursor.fetchone()

        if not row or not row[0]:
            user_states[uid] = "awaiting_major"
            return bot.send_message(uid, "üß† ŸÇÿ®ŸÑ ÿ£ŸÜ ŸÜÿ®ÿØÿ£ ÿßŸÑŸÑÿπÿ®ÿå ÿ£ÿÆÿ®ÿ±ŸÜÿß ÿ®ÿ™ÿÆÿµÿµŸÉ:")

        keyboard = InlineKeyboardMarkup(row_width=1)
        keyboard.add(
            InlineKeyboardButton("üîí ÿßŸÑÿπÿ® ŸÅŸä ÿßŸÑÿÆÿßÿµ", callback_data="game_private"),
            InlineKeyboardButton("üë• ÿßŸÑÿπÿ® ŸÅŸä ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©", switch_inline_query="game")
        )
        bot.edit_message_text(
            "üéÆ ÿßÿÆÿ™ÿ± ÿ∑ÿ±ŸäŸÇÿ© ÿßŸÑŸÑÿπÿ®:\n\n"
            "- üîí ŸÅŸä ÿßŸÑÿÆÿßÿµ (ÿ£ŸÑÿπÿßÿ® ÿ¥ÿÆÿµŸäÿ© ÿ≠ÿ≥ÿ® ÿ™ÿÆÿµÿµŸÉ)\n"
            "- üë• ŸÅŸä ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ© (ÿ¥ÿßÿ±ŸÉ ÿßŸÑÿ£ÿµÿØŸÇÿßÿ° ÿ®ÿßŸÑÿ™ÿ≠ÿØŸä!)",
            chat_id=c.message.chat.id,
            message_id=c.message.message_id,
            reply_markup=keyboard
        )

    elif c.data == "game_private":
        cursor.execute("SELECT major FROM users WHERE user_id = ?", (uid,))
        row = cursor.fetchone()
        major = row[0] if row else "ÿπÿßŸÖ"

        keyboard = InlineKeyboardMarkup(row_width=1)
        keyboard.add(
            InlineKeyboardButton("üß© Vocabulary Match", callback_data="game_vocab"),
            InlineKeyboardButton("‚è±Ô∏è ÿ™ÿ≠ÿØŸä ÿßŸÑÿ≥ÿ±ÿπÿ©", callback_data="game_speed"),
            InlineKeyboardButton("‚ùå ÿßŸÑÿ£ÿÆÿ∑ÿßÿ° ÿßŸÑÿ¥ÿßÿ¶ÿπÿ©", callback_data="game_mistakes"),
            InlineKeyboardButton("üß† ŸÑÿπÿ®ÿ© ÿßŸÑÿßÿ≥ÿ™ŸÜÿ™ÿßÿ¨", callback_data="inference_game"),
            InlineKeyboardButton("‚¨ÖÔ∏è ÿ±ÿ¨Ÿàÿπ", callback_data="go_games")
        )
        bot.edit_message_text(
            f"üéì ÿ™ÿÆÿµÿµŸÉ ÿßŸÑÿ≠ÿßŸÑŸä: {major}\n"
            "ÿßÿÆÿ™ÿ± ŸÑÿπÿ®ÿ© üëá",
            chat_id=c.message.chat.id,
            message_id=c.message.message_id,
            reply_markup=keyboard
        )

    elif c.data.startswith("soon_"):
        feature_name = {
            "soon_review": "üìö ŸÖŸäÿ≤ÿ© ÿßŸÑŸÖÿ±ÿßÿ¨ÿπÿ© ÿßŸÑÿ≥ÿ±Ÿäÿπÿ©",
            "soon_summary": "üìÑ ŸÖŸÑÿÆÿµÿßÿ™ PDF",
            "soon_anki": "üß† ÿ®ÿ∑ÿßŸÇÿßÿ™ Anki",
            "soon_account": "‚öôÔ∏è ÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿ≠ÿ≥ÿßÿ®",
        }.get(c.data, "Ÿáÿ∞Ÿá ÿßŸÑŸÖŸäÿ≤ÿ©")

        bot.answer_callback_query(c.id)
        bot.send_message(c.message.chat.id, f"{feature_name} ÿ≥ÿ™ŸÉŸàŸÜ ŸÖÿ™ÿßÿ≠ÿ© ŸÇÿ±Ÿäÿ®Ÿãÿß... üöß")

    elif data.startswith("game_"):
        game_type = data.split("_")[1]
        uid = c.from_user.id
        if game_type == "vocab":
            if not can_play_game_today(uid, "vocab"):
                return bot.send_message(uid, "‚ùå ŸÑŸÇÿØ ŸÑÿπÿ®ÿ™ Ÿáÿ∞Ÿá ÿßŸÑŸÑÿπÿ®ÿ© ÿßŸÑŸäŸàŸÖ. ÿ¨ÿ±ÿ® ŸÑÿπÿ®ÿ© ÿ£ÿÆÿ±Ÿâ ÿ£Ÿà ÿßŸÜÿ™ÿ∏ÿ± ŸÑŸÑÿ∫ÿØ.")
            record_game_attempt(uid, "vocab")

            raw = generate_vocabulary_game(c.from_user.id, get_user_major(c.from_user.id))  # ‚Üê ÿßÿ≥ÿ™ÿØÿπÿßÿ° ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä
            try:
                q = json.loads(raw)
                question = q["question"]
                options = q["options"]
                correct_index = q["correct_index"]

                keyboard = InlineKeyboardMarkup()
                for i, option in enumerate(options):
                    callback = f"ans_vocab_{i}_{correct_index}"  # ‚úÖÁµ±‰∏Ä ÿßŸÑÿ¥ŸÉŸÑ

                    bot.send_message(c.message.chat.id, question, reply_markup=keyboard)

            except Exception as e:
                logging.warning(f"‚ùå ŸÅÿ¥ŸÑ ÿ™ŸàŸÑŸäÿØ ÿ≥ÿ§ÿßŸÑ AI: {e}")
                bot.send_message(c.message.chat.id, "‚ùå ÿ™ÿπÿ∞ÿ± ÿ™ŸàŸÑŸäÿØ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ¢ŸÜ. ÿ≠ÿßŸàŸÑ ŸÑÿßÿ≠ŸÇŸãÿß.")
        elif game_type == "speed":
            if not can_play_game_today(uid, "speed"):
                return bot.send_message(uid, "‚ùå ŸÑŸÇÿØ ŸÑÿπÿ®ÿ™ Ÿáÿ∞Ÿá ÿßŸÑŸÑÿπÿ®ÿ© ÿßŸÑŸäŸàŸÖ. ÿ¨ÿ±ÿ® ŸÑÿπÿ®ÿ© ÿ£ÿÆÿ±Ÿâ ÿ£Ÿà ÿßŸÜÿ™ÿ∏ÿ± ŸÑŸÑÿ∫ÿØ.")
            record_game_attempt(uid, "vocab")
            raw = generate_speed_challenge(c.from_user.id, get_user_major(c.from_user.id))  # ‚Üê ÿßÿ≥ÿ™ÿØÿπÿßÿ° ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä
            try:
                q = json.loads(raw)
                question = q["question"]
                options = q["options"]
                correct_index = q["correct_index"]

                keyboard = InlineKeyboardMarkup()
                for i, option in enumerate(options):
                    callback = f"ans_speed_{i}_{correct_index}"  # ‚úÖÁµ±‰∏Ä ÿßŸÑÿ¥ŸÉŸÑ
                    bot.send_message(c.message.chat.id, question, reply_markup=keyboard)

            except Exception as e:
                logging.warning(f"‚ùå ŸÅÿ¥ŸÑ ÿ™ŸàŸÑŸäÿØ ÿ≥ÿ§ÿßŸÑ AI: {e}")
                bot.send_message(c.message.chat.id, "‚ùå ÿ™ÿπÿ∞ÿ± ÿ™ŸàŸÑŸäÿØ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ¢ŸÜ. ÿ≠ÿßŸàŸÑ ŸÑÿßÿ≠ŸÇŸãÿß.")
        elif game_type == "errors":
            if not can_play_game_today(uid, "errors"):
                return bot.send_message(uid, "‚ùå ŸÑŸÇÿØ ŸÑÿπÿ®ÿ™ Ÿáÿ∞Ÿá ÿßŸÑŸÑÿπÿ®ÿ© ÿßŸÑŸäŸàŸÖ. ÿ¨ÿ±ÿ® ŸÑÿπÿ®ÿ© ÿ£ÿÆÿ±Ÿâ ÿ£Ÿà ÿßŸÜÿ™ÿ∏ÿ± ŸÑŸÑÿ∫ÿØ.")
            record_game_attempt(uid, "vocab")
            raw = generate_common_mistakes_game(c.from_user.id, get_user_major(c.from_user.id))  # ‚Üê ÿßÿ≥ÿ™ÿØÿπÿßÿ° ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä
            try:
                q = json.loads(raw)
                question = q["question"]
                options = q["options"]
                correct_index = q["correct_index"]

                keyboard = InlineKeyboardMarkup()
                for i, option in enumerate(options):
                    callback = f"ans_errors_{i}_{correct_index}"  # ‚úÖÁµ±‰∏Ä ÿßŸÑÿ¥ŸÉŸÑ

                    bot.send_message(c.message.chat.id, question, reply_markup=keyboard)

            except Exception as e:
                logging.warning(f"‚ùå ŸÅÿ¥ŸÑ ÿ™ŸàŸÑŸäÿØ ÿ≥ÿ§ÿßŸÑ AI: {e}")
                bot.send_message(c.message.chat.id, "‚ùå ÿ™ÿπÿ∞ÿ± ÿ™ŸàŸÑŸäÿØ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ¢ŸÜ. ÿ≠ÿßŸàŸÑ ŸÑÿßÿ≠ŸÇŸãÿß.")

        elif data == "inference_game":
            if not can_play_game_today(uid, "inference_game"):
                return bot.send_message(uid, "‚ùå ŸÑŸÇÿØ ŸÑÿπÿ®ÿ™ Ÿáÿ∞Ÿá ÿßŸÑŸÑÿπÿ®ÿ© ÿßŸÑŸäŸàŸÖ. ÿ¨ÿ±ÿ® ŸÑÿπÿ®ÿ© ÿ£ÿÆÿ±Ÿâ ÿ£Ÿà ÿßŸÜÿ™ÿ∏ÿ± ŸÑŸÑÿ∫ÿØ.")
            record_game_attempt(uid, "vocab")
            raw = generate_inference_game(c.from_user.id, get_user_major(c.from_user.id))
            try:
                q = json.loads(raw)
                question = q["question"]
                options = q["options"]
                correct_index = q["correct_index"]

                keyboard = InlineKeyboardMarkup()
                for i, option in enumerate(options):
                    callback = f"ans_infer_{i}_{correct_index}"
                    keyboard.add(InlineKeyboardButton(option, callback_data=callback))

                bot.send_message(c.message.chat.id, question, reply_markup=keyboard)

            except Exception as e:
                logging.warning(f"‚ùå ŸÅÿ¥ŸÑ ÿ™ŸàŸÑŸäÿØ ÿ≥ÿ§ÿßŸÑ ÿßÿ≥ÿ™ŸÜÿ™ÿßÿ¨: {e}")
                bot.send_message(c.message.chat.id, "‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ŸàŸÑŸäÿØ ŸÑÿπÿ®ÿ© ÿßŸÑÿßÿ≥ÿ™ŸÜÿ™ÿßÿ¨.")

        elif data.startswith("ans_"):
            _, game_type, selected, correct = data.split("_")
            selected = int(selected)
            correct = int(correct)

            if selected == correct:
                bot.answer_callback_query(c.id, "‚úÖ ÿ•ÿ¨ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ©!")
            else:
                bot.answer_callback_query(c.id, "‚ùå ÿÆÿßÿ∑ÿ¶ÿ©. ŸÅŸÉÿ± ÿ£ŸÉÿ´ÿ±...")

@bot.message_handler(func=lambda m: user_states.get(m.from_user.id) == "awaiting_major", content_types=['text'])
def set_user_major(msg):
    major = msg.text.strip()
    uid = msg.from_user.id

    cursor.execute("INSERT OR REPLACE INTO users(user_id, major) VALUES(?, ?)", (uid, major))
    conn.commit()
    user_states.pop(uid, None)

    bot.send_message(uid,
        f"‚úÖ ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿ™ÿÆÿµÿµŸÉ: {major}\n"
        "ÿßŸÑÿ¢ŸÜ ŸäŸÖŸÉŸÜŸÉ ÿ™ŸàŸÑŸäÿØ ÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™ ÿ£Ÿà ÿ™ÿ¨ÿ±ÿ®ÿ© ÿßŸÑÿ£ŸÑÿπÿßÿ® ÿßŸÑÿ™ÿπŸÑŸäŸÖŸäÿ©."
    )
    
@bot.callback_query_handler(func=lambda c: c.data.startswith("major_"))
def cb_major(c):
    sel = c.data.split("_", 1)[1]
    uid = c.from_user.id

    if sel == "custom":
        user_states[uid] = "awaiting_major"
        bot.send_message(uid, "‚úèÔ∏è ŸÖŸÜ ŸÅÿ∂ŸÑŸÉ ÿ£ÿ±ÿ≥ŸÑ ÿßÿ≥ŸÖ ÿ™ÿÆÿµÿµŸÉ ÿ®ÿØŸÇÿ©.")
    
    elif c.data == "go_back_home":
    # ÿ•ÿπÿßÿØÿ© ÿπÿ±ÿ∂ Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑÿ®ÿØÿßŸäÿ©
        cmd_start(c.message)

    else:
        # set directly
        cursor.execute("INSERT OR REPLACE INTO users(user_id, major) VALUES(?, ?)", (uid, sel))
        conn.commit()
        bot.send_message(uid,
            f"‚úÖ ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿØ ÿ™ÿÆÿµÿµŸÉ: {sel}\n"
            "ÿßŸÑÿ¢ŸÜ ÿ£ÿ±ÿ≥ŸÑ ŸÖŸÑŸÅ (PDF/DOCX/TXT) ÿ£Ÿà ŸÜÿµŸãÿß ŸÖÿ®ÿßÿ¥ÿ±Ÿãÿß ŸÑÿ™ŸàŸÑŸäÿØ ÿßÿÆÿ™ÿ®ÿßÿ±ŸÉ.")


@bot.message_handler(func=lambda m: user_states.get(m.from_user.id) == "awaiting_major", content_types=['text'])
def set_custom_major(msg):
    major = msg.text.strip()
    uid   = msg.from_user.id

    cursor.execute(
        "INSERT OR REPLACE INTO users(user_id, major) VALUES(?, ?)",
        (uid, major)
    )
    conn.commit()
    user_states.pop(uid, None)

    bot.send_message(uid,
        f"‚úÖ ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿ™ÿÆÿµÿµŸÉ: \"{major}\"\n"
        "ÿßŸÑÿ¢ŸÜ ÿ£ÿ±ÿ≥ŸÑ ŸÖŸÑŸÅ (PDF/DOCX/TXT) ÿ£Ÿà ŸÜÿµŸãÿß ŸÖÿ®ÿßÿ¥ÿ±Ÿãÿß ŸÑÿ™ŸàŸÑŸäÿØ ÿßÿÆÿ™ÿ®ÿßÿ±ŸÉ."
    )
    # notify admin
    bot.send_message(ADMIN_ID,
        f"üÜï ÿ™ÿÆÿµÿµ ÿ¨ÿØŸäÿØ ÿ£Ÿèÿ±ÿ≥ŸÑ ŸÖŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ:\n"
        f"üë§ @{msg.from_user.username or msg.from_user.id}\n"
        f"üìö ÿßŸÑÿ™ÿÆÿµÿµ: {major}"
    )

@bot.message_handler(content_types=['document'])
def handle_document(msg):
    uid = msg.from_user.id
    if not can_generate(uid):
        return bot.send_message(uid, "‚ö†Ô∏è ŸÑŸÇÿØ ÿßÿ≥ÿ™ŸÜŸÅÿØÿ™ 3 ÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™ ŸÖÿ¨ÿßŸÜŸäÿ© Ÿáÿ∞ÿß ÿßŸÑÿ¥Ÿáÿ±.")

    file_info = bot.get_file(msg.document.file_id)
    MAX_FILE_SIZE = 5 * 1024 * 1024  # 5MB

    if file_info.file_size > MAX_FILE_SIZE:
        return bot.send_message(uid, "‚ùå ÿßŸÑŸÖŸÑŸÅ ŸÉÿ®Ÿäÿ± ÿ¨ÿØŸãÿß. ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸáŸà 5 ŸÖŸäÿ¨ÿßÿ®ÿßŸäÿ™.")
    data      = bot.download_file(file_info.file_path)
    os.makedirs("downloads", exist_ok=True)
    path = os.path.join("downloads", msg.document.file_name)
    with open(path, "wb") as f:
        f.write(data)

    ext = path.rsplit(".", 1)[-1].lower()
    if ext == "pdf":
        text = extract_text_from_pdf(path)
    elif ext == "docx":
        text = extract_text_from_docx(path)
    elif ext == "txt":
        text = extract_text_from_txt(path)
    else:
        return bot.send_message(uid, "‚ùå ÿµŸäÿ∫ÿ© ÿ∫Ÿäÿ± ŸÖÿØÿπŸàŸÖÿ©. ÿ£ÿ±ÿ≥ŸÑ PDF ÿ£Ÿà DOCX ÿ£Ÿà TXT.")

    cursor.execute("SELECT major FROM users WHERE user_id = ?", (uid,))
    major = cursor.fetchone()[0] or "ÿπÿßŸÖ"

    bot.send_message(uid, "üß† ÿ¨ÿßÿ±Ÿä ÿ™ŸàŸÑŸäÿØ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™... ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±")
    quizzes = generate_quizzes_from_text(text[:3000], major, chat_id=uid, num_quizzes=10)
    if quizzes and len(quizzes) > 0:
        send_quizzes_as_polls(uid, quizzes)
        increment_count(uid)
    else:
        bot.send_message(uid, "‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ŸàŸÑŸäÿØ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™. ÿ≠ÿßŸàŸÑ ŸÑÿßÿ≠ŸÇŸãÿß.")

@bot.message_handler(content_types=['text'])
def handle_text(msg):
    uid = msg.chat.id
    # skip if awaiting major
    if user_states.get(uid) == "awaiting_major":
        return

    if not can_generate(uid):
        return bot.send_message(uid, "‚ö†Ô∏è ŸÑŸÇÿØ ÿßÿ≥ÿ™ŸÜŸÅÿØÿ™ 3 ÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™ ŸÖÿ¨ÿßŸÜŸäÿ© Ÿáÿ∞ÿß ÿßŸÑÿ¥Ÿáÿ±.")

    text = msg.text.strip()
    cursor.execute("SELECT major FROM users WHERE user_id = ?", (uid,))
    major = cursor.fetchone()[0] or "ÿπÿßŸÖ"

    bot.send_message(uid, "üß† ÿ¨ÿßÿ±Ÿä ÿ™ŸàŸÑŸäÿØ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™ ŸÖŸÜ ÿßŸÑŸÜÿµ... ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±")
    quizzes = generate_quizzes_from_text(text[:3000], major, chat_id=uid, num_quizzes=10)
    if quizzes and len(quizzes) > 0:
        send_quizzes_as_polls(uid, quizzes)
        increment_count(uid)
    else:
        bot.send_message(uid, "‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ŸàŸÑŸäÿØ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™. ÿ≠ÿßŸàŸÑ ŸÑÿßÿ≠ŸÇŸãÿß.")



# -------------------------------------------------------------------
#                   inference handler
# -------------------------------------------------------------------

user_states = {}
@bot.message_handler(commands=['submit_inference'])
def handle_submit_inference(msg):
    uid = msg.from_user.id
    user_states[uid] = {"state": "awaiting_inference_question", "temp": {}}
    bot.send_message(uid, "üß† ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑÿ¢ŸÜ ÿ≥ŸäŸÜÿßÿ±ŸäŸà ÿ£Ÿà ÿ≥ÿ§ÿßŸÑŸãÿß ŸÑŸÑÿßÿπÿ®ŸäŸÜ (ŸÖÿ´ÿßŸÑ: ŸÉŸäŸÅ ÿ™ÿ™ÿµÿ±ŸÅ ŸÅŸä Ÿáÿ∞ÿß ÿßŸÑŸÖŸàŸÇŸÅÿü)")

@bot.message_handler(func=lambda m: user_states.get(m.from_user.id, {}).get("state") in [
    "awaiting_inference_question", "awaiting_inference_options", "awaiting_inference_correct"])
def handle_inference_submission(msg):
    uid = msg.from_user.id
    state = user_states.get(uid, {})
    temp = state.get("temp", {})

    if state["state"] == "awaiting_inference_question":
        temp["question"] = msg.text.strip()
        user_states[uid] = {"state": "awaiting_inference_options", "temp": temp}
        bot.send_message(uid, "‚úèÔ∏è ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑÿ¢ŸÜ 4 ÿÆŸäÿßÿ±ÿßÿ™ÿå ŸÉŸÑ ÿÆŸäÿßÿ± ŸÅŸä ÿ≥ÿ∑ÿ± ŸÖŸÜŸÅÿµŸÑ.")

    elif state["state"] == "awaiting_inference_options":
        options = msg.text.strip().split("\n")
        if len(options) != 4:
            return bot.send_message(uid, "‚ö†Ô∏è Ÿäÿ¨ÿ® ÿ£ŸÜ ÿ™ÿ±ÿ≥ŸÑ 4 ÿÆŸäÿßÿ±ÿßÿ™ ŸÅŸÇÿ∑ÿå ŸÉŸÑ ÿÆŸäÿßÿ± ŸÅŸä ÿ≥ÿ∑ÿ±.")
        temp["options"] = options
        user_states[uid] = {"state": "awaiting_inference_correct", "temp": temp}
        bot.send_message(uid, "‚úÖ ŸÖÿß ŸáŸà ÿ±ŸÇŸÖ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©ÿü (ŸÖŸÜ 0 ÿ•ŸÑŸâ 3)")

    elif state["state"] == "awaiting_inference_correct":
        try:
            correct = int(msg.text.strip())
            if correct not in [0, 1, 2, 3]:
                raise ValueError()
        except:
            return bot.send_message(uid, "‚ö†Ô∏è ÿ£ÿ±ÿ≥ŸÑ ÿ±ŸÇŸÖŸãÿß ÿµÿ≠Ÿäÿ≠Ÿãÿß ŸÖŸÜ 0 ÿ•ŸÑŸâ 3 ŸÅŸÇÿ∑.")
        
        # ÿ≠ŸÅÿ∏ ŸÅŸä ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
        q = temp["question"]
        options = temp["options"]
        options_str = json.dumps(options)
        cursor.execute("""
        INSERT INTO inference_questions (question, options, correct_index, submitted_by)
        VALUES (?, ?, ?, ?)
        """, (q, options_str, correct, uid))
        conn.commit()

        user_states.pop(uid, None)
        bot.send_message(uid, "üéâ ÿ™ŸÖ ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿßŸÇÿ™ÿ±ÿßÿ≠ŸÉ ÿ®ŸÜÿ¨ÿßÿ≠! ÿ≥Ÿäÿ™ŸÖ ŸÖÿ±ÿßÿ¨ÿπÿ™Ÿá ŸÇÿ±Ÿäÿ®Ÿãÿß. ÿ¥ŸÉÿ±ÿßŸã ŸÑŸÖÿ≥ÿßŸáŸÖÿ™ŸÉ üôè")
# -------------------------------------------------------------------
#                           Run Bot
# -------------------------------------------------------------------

# Ÿàÿßÿ¨Ÿáÿ© Flask ŸÑŸÑŸÅÿ≠ÿµ
app = Flask(__name__)

@app.route('/')
def home():
    return "‚úÖ ÿßŸÑÿ®Ÿàÿ™ ŸäÿπŸÖŸÑ ÿßŸÑÿ¢ŸÜ"

# ÿ®ÿØÿ° ÿßŸÑÿ®Ÿàÿ™

# ÿ™ÿ¥ÿ∫ŸäŸÑ ÿ®Ÿàÿ™ ÿ™ŸäŸÑŸäÿ∫ÿ±ÿßŸÖ ŸÅŸä Thread ŸÖŸÜŸÅÿµŸÑ
def run_bot():
    print("ü§ñ Bot polling started...")
    bot.infinity_polling()

threading.Thread(target=run_bot).start()

# ÿ™ÿ¥ÿ∫ŸäŸÑ ÿÆÿßÿØŸÖ Flask ÿπŸÑŸâ ÿßŸÑŸÖŸÜŸÅÿ∞ ÿßŸÑÿ∞Ÿä ÿ™ÿ≠ÿØÿØŸá Render
if __name__ == "__main__":
    port = int(os.environ.get("PORT", 5000))  # Render ŸäŸàŸÅÿ± PORT ŸÉŸÖÿ™ÿ∫Ÿäÿ± ÿ®Ÿäÿ¶ÿ©
    app.run(host="0.0.0.0", port=port)
